<!DOCTYPE html>
<html>
<head>
  <meta charsetp="UTF-8">
  <meta name="viewport" content="width=device-width" />
</head>
<body bgcolor="black">
    <style>
        #myCanvas {touch-action: none;
        -webkit-touch-callout:none;
        -webkit-user-select:none;
        -khtml-user-select:none;
        -moz-user-select:none;
        -ms-user-select:none;
        user-select:none;
        -webkit-tap-highlight-color:rgba(0,0,0,0);
        }

    </style>

<canvas id="myCanvas" width="640" height="480" style="border:0px solid #d3d3d3;">
Use different browser.
</canvas>
<script>


    var developmode = false;

    //
    //
    //
    // Bug with laserwall close together??
    //
    // 
    // randomize grenade throwing a bit * test
    // jump from ladder * test
    // add + turrets shoot slime + slime eats villagers + villagers can shoot +
    // eggs get eaten by slime.
    // possible bug ai bottom of slime can pass through slime.
    //
    // fix problems with laserwall slime and jumping monsters and flickering
    // ai.
    // 
    // Conversion project from my Monkey 2 game 'Mine Slime and Monsters'..
    //
    // Conversion note : The procedural house and tree generators from the original
    // Monkey2 version were not added.
    //
    //
    //
    //
    //
    //
    //
    var c=document.getElementById("myCanvas");
    var ctx=c.getContext("2d");

	var offscreenCanvas = document.createElement("canvas");

	var ctx2 = offscreenCanvas.getContext("2d")

    // load the tiles..
    var tileImage = new Image();
    tileImage.src = 'Data/tiles.png';

    // load the sprites..
    var spriteImage = new Image();
    spriteImage.src = 'Data/sprites.png';
    
    // load the sprites..
    var iconImage = new Image();
    iconImage.src = 'Data/Icons.png';
    
    // load the sprites..
    var mediumIconImage = new Image();
    mediumIconImage.src = 'Data/mediumIcons.png';

    // Add event listeners for reading keydown and keyup events from the keyboard..
    //
    window.addEventListener("keydown",kd,true);
    window.addEventListener("keyup",ku,true);

    
    //
    //
    // NOTE : handle connect/disconnect not included - JOYPAD
    let gamepadIndex;
    window.addEventListener('gamepadconnected', (event) => {
        gamepadIndex = event.gamepad.index;
    });
    var padCountDown=0;
    // now print the axes on the connected gamepad, for example: 
    setInterval(() => {
        if(gamepadIndex !== undefined) {
            // a gamepad is connected and has an index
            const myGamepad = navigator.getGamepads()[gamepadIndex];
            //console.log(`Left stick at (${myGamepad.axes[0]}, ${myGamepad.axes[1]})` );
            //console.log(`Right stick at (${myGamepad.axes[2]}, ${myGamepad.axes[3]})` );
            var a=-1
            for(var i=0;i<16;i++){
                if(myGamepad.buttons[i].pressed==true)a=i
            }
            //if(a!=-1)console.log(a)
            
            Controller.Left = false
            Controller.Right = false
            Controller.Up = false
            Controller.Down = false
            Controller.Jump = false
            Controller.ShotGun = false
            Controller.Grenade = false
            Controller.MiniMap = false
            Controller.LaserWall = false
            if(myGamepad.buttons[1].pressed==true){
                Controller.LaserWall = true
            }
            if(myGamepad.buttons[9].pressed==true){
                Controller.MiniMap = true
            }
            if(myGamepad.buttons[3].pressed==true){
                Controller.Grenade = true
            }
            if(myGamepad.buttons[2].pressed==true){
                Controller.ShotGun = true
            }
            if(myGamepad.buttons[0].pressed==true){
                Controller.Jump = true
            }
            if(myGamepad.buttons[14].pressed==true){
                Controller.Left = true
            }
            if(myGamepad.buttons[12].pressed==true){
                Controller.Up = true
            }
            if(myGamepad.buttons[15].pressed==true){
                Controller.Right = true

            } 
            if(myGamepad.buttons[13].pressed==true){
                Controller.Down = true
            } 


        }
    }, 10) // print axes 10 times per second

    //
    // With this we can read the controller status. In this example
    // we use the keyboard to set these flags..
    //
    var Controller = {
        Right:false,
        Left:false,
        Up:false,
        Down:false,
        ShotGun:false,
        LaserWall:false,
        Grenade:false,
        Mine:false,
        Jump:false,
        MiniMap:false,
    } 
    window.addEventListener("touchend", touchHandler,false);
    window.addEventListener("touchstart", touchHandler,false);					
    window.addEventListener("touchmove", touchHandler,false);
    window.addEventListener("resize", resizeHandler,false);
    
    document.addEventListener(
    "keydown",
    (e) => {
        if (e.key === "Enter") {
        toggleFullScreen();
        }
    },
    false
    );


    var touchControlVisible = false // press screen to activate touch screen controls...

    var setToggleFullScreenMode = false

    // w and h of the tile image file
    var tileImageWidth = 640
    var tileImageHeight = 480;
    var tileImageCellSize = 32;
    var maxColumns = tileImageHeight/tileImageCellSize
    var maxRows = tileImageWidth/tileImageCellSize
    var tileAtlasIndex = [];
    bufferTileAtlas() // Buffer the coordinates of the tile cells

    var drawDistance = 1400

    var mapwidth=320;
    var mapheight=240;
    var screenwidth=window.innerWidth+48;
    var screenheight=window.innerHeight+48;
    var tilewidth=32;
    var tileheight=32;

    // random == 2
    var egggrowspeed = 1000
    var egghatchspeed = 1000
    //var egghatchspeed= 0.1 //how fast eggs hatch
    var egglayingfreq = 0.1 // lay lots of eggs 1 lay less eggs 0 '0 to 1
    var startingeggfreq = 0.2 //0 to 1 0 is none 1 is full
    var maxflyingmonsters=30
    var maxwalkingmonsters=30

    var gamestate = "select" // menu and st

    var touchButtonWidth = screenwidth*.064
    var touchButtonHeight = screenheight/16

    var touchControlsLeftX = screenwidth*.13
    var touchControlsLeftY = screenheight-(touchButtonHeight*3)-56//.66
    var touchControlsRightX = screenwidth*.70
    var touchControlsRightY = screenheight-(touchButtonHeight*3)-56//.66

    //var touchControlsLeftX = screenwidth*.13
    //var touchControlsLeftY = screenheight*.63//.66
    //var touchControlsRightX = screenwidth*.70
    //var touchControlsRightY = screenheight*.63//.66


    //var touchButtonWidth = screenwidth*.064
    //var touchButtonHeight = screenheight*.064
    var touchAreaDownX = []
    var touchAreaDownY = []
    var touchAreaWidth = []
    var touchAreaHeight = []

    class flash{
        constructor(x,y){ // pixel position
            this.x = x
            this.y = y
            this.alpha = 1
            this.deleteme = false   
        }
        update(){
            this.alpha -= 0.20
            if(this.alpha <= 0)this.deleteme = true
        }
        draw(){

        }
    }

    class building{
        constructor(x,y,w,bw,bh,isshop){
            //this.image:Image
            //this.icanvas:Canvas
            this.can = document.createElement("canvas")
	        this.context = this.can.getContext("2d")            
            
            this.image = 
            this.px,this.py
            this.totalwidth
            this.blockhouse=1
            this.blockdoor=2
            //' For collision (enter/flee in home/shop)
            this.doorx,this.doory
            this.doorwidth,this.doorheight
            this.blocksmallwindow=3
            this.blockwidewindow=4
            this.blockcrateleft=5
            this.blockcrateright=6
            this.blockiceboxleft=7
            this.blockiceboxright=7
            this.blocktoiletleft=8
            this.blocktoiletright=9
            this.blockfrontcrate=10
            this.blockrooftop=11
            this.blockchimney=12
            this.blockshopsign=13
            this.houselayer = new Array(3).fill(0);
            this.rooftoplayer = new Array(3).fill(0);
            this.chimneylayer = new Array(3).fill(0);
            this.doorlayer = new Array(3).fill(0);
            this.windowlayer = new Array(3).fill(0);
            this.housesidelayer = new Array(2).fill(0);
            this.shopsignlayer = new Array(3).fill(0);
            this.frontlayer = new Array(6).fill(0);           
            this.bw,this.bh

            this.bw = bw
            this.bh = bh
            //image = New Image(bw*(w+2),bh*2)
            //image.Handle=New Vec2f( 0,0 )
            //icanvas = New Canvas(image)	
            this.px = x
            this.py = y+100
            this.totalwidth = w
            this.makehouse(w,isshop)
            var opx=this.px
            var opy=this.py
            this.px=bw
            this.py=bh
            this.bufferdraw(this.context)
            this.px = opx
            this.py = opy-bh
            //icanvas.Flush()
        }
        makehouse(w,isshop){



            //' Make the base house blocks
            for(var i=0;i<w;i+=1){
                this.houselayer[i] = this.blockhouse
            }
            //' Create the items at the side of the houses
            if(randomRange(0,10)<5){
                //' add to which side(s)
                var sides="left"			
                if(randomRange(0,10)<3)sides="right" 
                if(randomRange(0,10)<3)sides="both"
                //' Add items to side(s)
                if(sides=="left" || sides=="both"){ 
                    this.housesidelayer[0] = this.blocktoiletleft
                    if(randomRange(0,10)<3){ 
                        this.housesidelayer[0] = this.blockcrateleft
                    }
                    if(randomRange(0,10)<3){
                        this.housesidelayer[0] = this.blockiceboxleft
                    }	
                }				
                if(sides=="right" || sides=="both"){ 
                    this.housesidelayer[1] = this.blocktoiletright
                    if(randomRange(0,10)<3){
                        this.housesidelayer[1] = this.blockcrateright
                    }
                    if(randomRange(0,10)<3){
                        this.housesidelayer[1] = this.blockiceboxright
                    }	
                }				
            }
            //'Create the crates at the front of the house
            for(var i=0;i<(w*2)-2;i+=1){
                if(randomRange(0,10)<2){
                    this.frontlayer[i] = this.blockfrontcrate
                }

            }
            //'Create windows
            //Select w
            //    Case 2
            if(w==2)this.windowlayer[0] = this.blocksmallwindow
            //    Case 3
            if(w==3)this.windowlayer[0] = this.blockwidewindow
            //End Select
            //' create door
            //Select w
            //    Case 1
            if(w==1){
                this.doorlayer[0] = this.blockdoor
                if(isshop)this.shopsignlayer[0] = this.blockshopsign
            }
            //    Case 2
            if(w==2){
                this.doorlayer[1] = this.blockdoor
                if(isshop)this.shopsignlayer[1] = this.blockshopsign				
            }
            //    Case 3
            if(w==3){
                this.doorlayer[2] = this.blockdoor
                if(isshop)this.shopsignlayer[2] = this.blockshopsign
            }
            //End Select
            //' rooftop
            //Select w
            //    Case 1
            if(w==1){
                this.rooftoplayer[0] = this.blockrooftop
            }
            //    Case 2
            if(w==2){
                this.rooftoplayer[0] = this.blockrooftop
                this.rooftoplayer[1] = this.blockrooftop
            }
            //    Case 3
            if(w==3){
                this.rooftoplayer[0] = this.blockrooftop
                this.rooftoplayer[1] = this.blockrooftop
                this.rooftoplayer[2] = this.blockrooftop
            }
            //End Select
            //' chimney
            //Select w
            //    Case 1
            if(w==1){
                this.chimneylayer[0] = this.blockchimney
            }
            //    Case 2
            if(w==2){
                this.chimneylayer[randomRange(0,2)] = this.blockchimney
            }
            //    Case 3
            if(w==3){
                this.chimneylayer[randomRange(0,3)] = this.blockchimney
            }
            //End Select
        
        }
        bufferdraw(context){
            //canvas.Clear(New Color(0,0,0,0))
            context.fillStyle = 'black'
            context.fillRect(0,0,context.width,context.height)
            //' Draw the house blocks
            for(var i=0;i<3;i+=1){	
                if(this.houselayer[i] == this.blockhouse){
                    context.fillStyle = 'rgb('+150+','+140+','+150+')'

                    //context.fillRect(0,0,100,100)
                    context.fillRect(this.px+(i*this.bw),this.py,this.bw+1,this.bh)

                    context.fillStyle = 'rgb('+200+','+200+','+200+')'
                    context.fillRect( this.px+(i*this.bw),this.py,this.bw,this.bh)
                    //'SetColor 230,230,230
                    //'shadow top
                    context.fillStyle = 'rgb('+60+','+60+','+60+')'
                    context.fillRect( this.px+(i*this.bw),this.py,this.bw,this.bh/15)
                    //'shadow bottom
                    context.fillStyle = 'rgb('+150+','+150+','+150+')'
                    context.fillRect( this.px+(i*this.bw),this.py+this.bh/1.1,this.bw,this.bh/8)
                    //'highlight left
                    if(i==0){ 
                        context.fillStyle = 'rgb('+220+','+220+','+220+')'
                        context.fillRect( this.px+(i*this.bw),this.py,1,this.bh/3)
                    }
                }
            }
            //' Draw the rooftop
            for(var i=0;i<3;i+=1){	
                if(this.rooftoplayer[i] == this.blockrooftop){
                    //'SetColor 200,100,100
                    context.fillStyle = 'rgb('+170+','+70+','+60+')'
                    context.fillRect( this.px+(i*this.bw),this.py-(this.bh/1.5),this.bw,this.bh-(this.bh/3))
                    //' Bottom shade
                    context.fillStyle = 'rgb('+130+','+50+','+30+')'
                    //'SetColor 200,100,100
                    context.fillRect( this.px+(i*this.bw),this.py-(this.bh/8),this.bw,this.bh/8)
                    //' top shade
                    context.fillStyle = 'rgb('+190+','+90+','+80+')'
                    context.fillRect( this.px+(i*this.bw),this.py-(this.bh/1.5),this.bw,1)
                    //' top shade
                    if(i==0){
                        //'horizontal
                        context.fillStyle = 'rgb('+220+','+120+','+110+')'
                        context.fillRect( this.px+(i*this.bw),this.py-(this.bh/1.5),this.bw/2,1)
                        //'vertical
                        context.fillStyle = 'rgb('+200+','+100+','+100+')'
                        context.fillRect( this.px+(i*this.bw),this.py-(this.bh/1.5),1,this.bh/3)
                    }
                }
            }

            //' Draw the chimney
            for(var i=0;i<3;i+=1){	
                if(this.chimneylayer[i] == this.blockchimney){
                    context.fillStyle = 'rgb('+100+','+100+','+100+')'
                    context.fillRect( this.px+(i*this.bw)+(this.bw/4),this.py-(this.bh/1.2),this.bw/2.5,this.bh/4)
                    //'chimney highlight
                    context.fillStyle = 'rgb('+140+','+130+','+120+')'
                    context.fillRect( this.px+(i*this.bw)+(this.bw/4),this.py-(this.bh/1.2),this.bw/2.5,1)
                }
            }		
            //'Draw the windows
            for(var i=0;i<3;i+=1){
                if(this.windowlayer[i] == this.blocksmallwindow){
                    context.fillStyle = 'rgb('+0+','+100+','+200+')'
                    context.fillRect( this.px+(i*this.bw)+(this.bw/3),this.py+(this.bh/5),this.bw-(this.bw/3),this.bh-(this.bh/2.5))
                    //' light bottom
                    context.fillStyle = 'rgb('+0+','+115+','+210+')'
                    context.fillRect( this.px+(i*this.bw)+(this.bw/3),this.py+(this.bh/2),this.bw-(this.bw/3),(this.bh/3.3))
                    //' dark bottom
                    context.fillStyle = 'rgb('+180+','+125+','+20+')'
                    context.fillRect( this.px+(i*this.bw)+(this.bw/3),this.py+(this.bh*.7),this.bw-(this.bw/3),(this.bh/8.3))

                }
                if(this.windowlayer[i] == this.blockwidewindow){
                    context.fillStyle = 'rgb('+0+','+100+','+200+')'
                    context.fillRect( this.px+(i*this.bw)+(this.bw/3),this.py+(this.bh/5),(this.bw*2)-(this.bw/3),this.bh-(this.bh/2.5))
                    //'light bottom
                    context.fillStyle = 'rgb('+0+','+115+','+210+')'
                    context.fillRect( this.px+(i*this.bw)+(this.bw/3),this.py+(this.bh/2),(this.bw*2)-(this.bw/3),(this.bh/3.3))
                    //'dark  bottom
                    context.fillStyle = 'rgb('+180+','+125+','+20+')'
                    context.fillRect( this.px+(i*this.bw)+(this.bw/3),this.py+(this.bh*.7),(this.bw*2)-(this.bw/3),(this.bh/8.3))

                }
            }
            //' Draw the door
            for(var i=0;i<3;i+=1){
                if(this.doorlayer[i] == this.blockdoor){
                    context.fillStyle = 'rgb('+100+','+50+','+50+')'
                    if(this.shopsignlayer[i] == this.blockshopsign){
                        context.fillStyle = 'rgb('+250+','+200+','+50+')'
                    }
                    context.fillRect( this.px+(i*this.bw)+(this.bw/5),this.py+(this.bh/5),this.bw-(this.bw/2),this.bh-(this.bh/4))
                    //' doorknob
                    context.fillStyle = 'rgb('+200+','+210+','+210+')'
                    context.fillRect( this.px+(i*this.bw)+(this.bw/2),this.py+(this.bh/1.7),(this.bw/9),(this.bh/9))
                    //'numberplate
                    context.fillStyle = 'rgb('+200+','+250+','+250+')'
                    context.fillRect( this.px+(i*this.bw)+(this.bw/1.3),this.py+(this.bh/3),(this.bw/9),(this.bh/9))
                    context.fillStyle = 'rgb('+10+','+50+','+50+')'
                    context.fillRect( this.px+(i*this.bw)+(this.bw/1.25),this.py+(this.bh/2.8),(this.bw/18),(this.bh/14))

                }
            }
            //' Draw the sides
            if(this.housesidelayer[0] == this.blocktoiletleft) this.drawtoilet(context,this.px,this.py,this.bw,this.bh,"left")
            if(this.housesidelayer[1] == this.blocktoiletright) this.drawtoilet(context,this.px,this.py,this.bw,this.bh,"right")
            if(this.housesidelayer[0] == this.blockcrateleft) this.drawsidecrate(context,this.px,this.py,this.bw,this.bh,"left")
            if(this.housesidelayer[1] == this.blockcrateright) this.drawsidecrate(context,this.px,this.py,this.bw,this.bh,"right")
            if(this.housesidelayer[0] == this.blockiceboxleft) this.drawsideicebox(context,this.px,this.py,this.bw,this.bh,"left")
            if(this.housesidelayer[1] == this.blockiceboxright) this.drawsideicebox(context,this.px,this.py,this.bw,this.bh,"right")
            
            //'Draw the crates  at the front of the house
            for(var i=0;i<(this.totalwidth*2)-2;i+=1){
                if(this.frontlayer[i] == this.blockfrontcrate){
                    context.fillStyle = 'rgb('+100+','+50+','+50+')'
                    context.fillRect( this.px+((this.bw/2)*i),this.py+this.bh/1.2,this.bw/4,this.bh/6.4)
                }
            }
            
            //'Draw the shop sign
            for(var i=0;i<this.totalwidth;i+=1){
                if(this.shopsignlayer[i] == this.blockshopsign){
                    context.fillStyle = 'rgb('+255+','+40+','+30+')'
                    var x=this.px+(this.bw*i)-this.bw/8
                    var y=this.py-this.bh/5
                    context.fillRect( x,y,this.bw*1.2,this.bh/3)
                    context.fillStyle = 'rgb('+255+','+255+','+255+')'
                    //'DrawText "Shop X",x+5,y+5
                    context.fillRect( x+this.bh/10,y+this.bh/12,4,4)
                }
            }
        }

        drawtoilet(context,x,y,w,h,side){
            if(side == "left"){
                var ltx=x-w/2
                var lty=y+(h/4)
                var rtx=ltx+(w/2)
                var rty=lty
                var lbx=ltx
                var lby=lty+(h-h/4)
                var rbx=ltx+(w/2)
                var rby=lby

                var toil = new Array(8).fill(0);   //New Float[8]
                toil[0] = ltx
                toil[1] = lty-(h/6)
                toil[2] = rtx
                toil[3] = rty
                toil[4] = rbx
                toil[5] = rby
                toil[6] = lbx
                toil[7] = lby
                
                context.fillStyle = 'rgb('+150+','+50+','+50 +')'
                //canvas.DrawPoly(toil)
                ctx.beginPath();
                ctx.moveTo(toil[0], toil[1]);
                for(var j=2;j<toil.length;j+=2){
                    ctx.lineTo(toil[j],toil[j+1]);
                }
                ctx.closePath();
                ctx.fill();                
                //'context.fillRect( x-w/2,y+10,w/2,h-10
            }else if(side=="right"){
                var ltx=(x)+(this.totalwidth*w)
                var lty=y+(h/4)
                var rtx=ltx+(w/2)
                var rty=lty
                var rbx=ltx+(w/2)
                var rby=rty+(h-h/4)
                var lbx=ltx
                var lby=rby
                context.fillStyle = 'rgb('+150+','+50+','+50+')'
                var box = new Array(8).fill(0);   //Float[8]
                box[0] = ltx
                box[1] = lty
                box[2] = rtx
                box[3] = rty-(h/6)
                box[4] = rbx
                box[5] = rby
                box[6] = lbx
                box[7] = lby
                //canvas.DrawPoly(box)
                ctx.beginPath();
                ctx.moveTo(box[0], box[1]);
                for(var j=2;j<box.length;j+=2){
                    ctx.lineTo(box[j],box[j+1]);
                }
                ctx.closePath();
                ctx.fill();                  

        //'		SetColor 100,50,50
        //'		context.fillRect( (x)+totalwidth*w,y+10,w/2,h-10
            }
        }
        drawsidecrate(context,x,y,w,h,side){
            if(side == "left"){
                //' pipe
                context.fillStyle = 'rgb('+120+','+120+','+120+')'
                context.fillRect( x-w/8,y,w/8,h)
                //'barrel
                context.fillStyle = 'rgb('+100+','+50+','+50+')'
                context.fillRect( x-w/3,y+(h/1.5),w/3,h-(h/1.5))
            }else if(side=="right"){
                //'pipe
                context.fillStyle = 'rgb('+120+','+120+','+120+')'
                context.fillRect( (x)+this.totalwidth*w,y,w/8,h)
                //'barrel
                context.fillStyle = 'rgb('+100+','+50+','+50+')'
                context.fillRect( (x)+this.totalwidth*w,y+(h/1.5),w/3,h-(h/1.5))
            }
        }
        drawsideicebox(context,x,y,w,h,side){
            if(side == "left"){
                var ltx=x-w/2
                var lty=y+(h/1.5)
                var rtx=ltx+(w/2)
                var rty=lty
                var lbx=ltx
                var lby=lty+(h-h/1.5)
                var rbx=ltx+(w/2)
                var rby=lby
                context.fillStyle = 'rgb('+200+','+200+','+200+')'
                var box = new Array(8).fill(0);   //New Float[8]
                box[0] = ltx
                box[1] = lty+(h/6)
                box[2] = rtx
                box[3] = rty
                box[4] = rbx
                box[5] = rby
                box[6] = lbx
                box[7] = lby
                //'context.fillRect( ltx,lty,w/2,h-(h/1.5)
                //canvas.DrawPoly(box)
                ctx.beginPath();
                ctx.moveTo(box[0], box[1]);
                for(var j=2;j<box.length;j+=2){
                    ctx.lineTo(box[j],box[j+1]);
                }
                ctx.closePath();
                ctx.fill();                   
             }else if(side=="right"){
                var ltx=(x)+(this.totalwidth*w)
                var lty=y+(h/1.5)
                var rtx=ltx+(w/2)
                var rty=lty
                var rbx=ltx+(w/2)
                var rby=rty+(h-h/1.5)
                var lbx=ltx
                var lby=rby
                context.fillStyle = 'rgb('+200+','+200+','+200+')'
                var box = new Array(8).fill(0);   //New Float[8]
                box[0] = ltx
                box[1] = lty
                box[2] = rtx
                box[3] = rty+h/6
                box[4] = rbx
                box[5] = rby
                box[6] = lbx
                box[7] = lby
                //canvas.DrawPoly(box)
                ctx.beginPath();
                ctx.moveTo(box[0], box[1]);
                for(var j=2;j<box.length;j+=2){
                    ctx.lineTo(box[j],box[j+1]);
                }
                ctx.closePath();
                ctx.fill();                   
                //'context.fillRect( (x)+totalwidth*w,y+(h/1.5),w/2,h-(h/1.5)
                }
        }
        draw(context,x,y){	
            //context.fillStyle = Color.White
            context.drawImage(this.can,x,y)
        }
    }

    // Monster Spawning Eggs. 
    //
    class egg{
        constructor(x,y){
            this.px,this.py
            this.deleteme = false
            // frame 0 = layed mini egg. 1,2 = growing. 3 is fullgrown
            this.frames = [0,1,2,3,4,5,6,7,8,9] // all the frames of the egg
            this.animationFrames =  [4,5,6,7,8,9] // cracked egg, to completely broken
            //
            ///
            
            this.inRange = true
            this.inRangeCnt = 0 
            this.inRangeCntMax = 30

            this.animationTime =    ["random","random","random",10,10,10,10,10,10,400] // frame times
            this.frame = 0;   
            this.state = "random"
            this.x = x;
            this.y = y;
            this.w = tilewidth;
            this.h = tileheight;
            this.px = this.x*this.w;
            this.py = this.y*this.h;
            this.spawned = false
    	    this.brightness = randomRange(100,200)
            this.inc=randomRangeFloat(1,2)
            this.maxBrightness = randomRange(150,300)
            //console.log("start"+this.px+','+this.py)
        }
        
        update(){   
            this.inRangeCnt+=1
            if(this.inRangeCnt>this.inRangeCntMax){
                this.inRangeCnt = 0;
                if(distanceM(myplayer.px,myplayer.py,this.px,this.py)>drawDistance){
                    this.inRange=false
                }else{
                    this.inRange=true
                }
            }
            if(this.deleteme==true)return
            //if(this.frame<4){
            //    this.brightness+=this.inc
            //    if(this.brightness>this.maxBrightness){
            //        this.inc=-this.inc
            //    }
            //    if(this.brightness<100){
            //        this.inc=-this.inc
            //   }
            //    
            //}
            if(this.state=="random"){

                // first 3(0,1,2) frames are random speed (a..b)
                if(this.frame<3 && randomRange(0,egggrowspeed)==1){
                    this.frame+=1
                }            
                // if on the 3rd frame then play animation
                if(this.frame==3 && randomRange(0,egghatchspeed)==1){
                    this.state="animate"
                }
            }
            // animate the sprite. if the last frame has ended then delete from egg list
            if(this.state=="animate"){
                this.animationTime[this.frame]-=1
                if(this.animationTime[this.frame]<=0){
                    this.frame+=1
                }
                if(this.spawned==false && this.frame==this.animationTime.length-3){
                    this.spawned = true
                    if(randomRange(0,2)==1){
                        if(myflyingmonster.length<maxflyingmonsters){
                            myflyingmonster.push(
                                    new theflyingmonster(
                                    this.x,this.y    
                                    )
                            );
                        }
                        }else{
                        if(mywalkingmonster.length<maxwalkingmonsters){
                            mywalkingmonster.push(
                                    new walkingmonster(
                                    this.x,this.y    
                                    )
                            );
                        }
                    }
                }
                if(this.frame==this.animationTime.length){
                    this.deleteme = true
                    mymap.mapfinal[this.x][this.y]=mymap.tileempty
                    //mymap.tilemap[this.x][this.y]
                }
            }
        }

    }


    class laserwall{
        constructor(x,y){
            // bottom x and y and top x and y
            this.bx,this.by
            this.tx,this.ty
            this.deleteme

            this.inRange = true
            this.inRangeCnt = 0
            this.inRangeCntMax = 30
            if(this.toclosetoother(x,y))return
            this.bx = x
            this.by = this.getbottomtile(x,y)
            this.tx = x
            this.ty = this.gettoptile(x,y-10)	
            if(distanceM(this.by,0,this.ty,0)>tileheight*12)this.deleteme=true
        }
        
        update(){
            this.inRangeCnt+=1
            if(this.inRangeCnt>this.inRangeCntMax){
                this.inRangeCnt = 0;
                if(distanceM(myplayer.px,myplayer.py,this.px,this.py)>drawDistance){
                    this.inRange=false
                }else{
                    this.inRange=true
                }
            }
            return  // Note : check
            /*
            // Make flying enemies turn into other direction
            // if close by
            For Local i:=Eachin myflyingmonster
                //If i.laserwait<>0 Then Continue
                Local mx
                If i.substate="right" Then mx=5 Else mx = -5
                If rectsoverlap(i.px-i.w+mx,i.py-i.h,i.w*3,i.h*3,tx-20,ty,40,(by-ty))
                //i.laserwait=160
                If i.substate="right" 
                    i.substate="left" 
                    i.x-=1
                    i.px -= 6
                Else 
                    i.substate="right"
                    i.x+=1
                    i.px += 6
                    
                }
                
                }
            }
        */
        }
        draw(){
            var dx=(screenwidth)/(mapwidth)
            var dy=(screenheight)/(mapheight)
            var x1=(tx/tilewidth)*dx
            var y1=(ty/tileheight)*dy
            var x2=(bx/tilewidth)*dx
            var y2=(by/tileheight)*dy
            var h=y2-y1
            
            //canvas.Color = Color.Yellow
            //SetColor 255,0,0		
            //canvas.DrawRect(x1+1,y1+1,3,h)

        }	
        // return true if new laserwall is to close to
        // existing laser wall
        toclosetoother(x,y){
            for(var i=0;i<mylaserwall.length;i+=1){
                if(distanceM(x,y,mylaserwall[i].tx,mylaserwall[i].ty) < tilewidth*4)return true
                if(distanceM(x,y,mylaserwall[i].bx,mylaserwall[i].by) < tilewidth*4)return true
            }
            return false
        }
        
        // Get the y position of bottom of the first tile above
        getbottomtile(x,y){
            var y2=y			
            var cnt=0
            while(cnt<10000){
                cnt+=1
                if(mymap.mapcollide(x,y2,2,2))return y2
                y2+=1
            }
            return y
            //NOTE:
        }
        
        //Get the y position of the top of the first tile below
        gettoptile(x,y){
            var y2=y
            var cnt=0
            while(cnt<1000){
                cnt+=1
                if(mymap.mapcollide(x,y2,2,2))return y2
                y2-=1
            }
            return y
            //NOTE
        }

    }

    //
    // Menu selection (choose 3 level sizes - untested for restarts) NOTE:
    //
    class menuselect{
        //this.image:Image	
        //this.icanvas:Canvas
        constructor(){
            //image=New Image(800,600)
            //image.Handle=New Vec2f( 0,0 )
            //icanvas=New Canvas( image )
            //icanvas.Clear(Color.Black)
            this.delay = 0
            this.maxDelay = 8
            this.m
            this.index=0
            this.sw1=(screenwidth*.20)
            this.sh1=150

            this.x1=25
            this.y1=(screenheight*.25)//100
            this.w1=150
            this.h1=150
            this.m1 = create2DArray(this.w1,this.h1)
            //SeedRnd(1)
            var m = new map(this.sw1,this.sh1,this.w1,this.h1,false)
            for(var x = 0;x<this.w1;x+=1){
                for(var y = 0;y<this.h1;y+=1){
                    this.m1[x][y] = m.mapfinal[x][y]
                }
            }
            //drawmap(icanvas,x,y,w,h)
            this.sw2 = (screenwidth*.20)//250
            this.sh2 = 250

            this.x2 = ((screenwidth)/2)-(this.sw2)
            this.y2 = (screenheight*.25)//100
            this.w2 = 250
            this.h2 = 250
            this.m2 = create2DArray(this.w2,this.h2)
            var m = new map(this.sw2,this.sh2,this.w2,this.h2,false)
            for(var x = 0;x<this.w2;x+=1){
                for(var y = 0;y<this.h2;y+=1){
                    this.m2[x][y] = m.mapfinal[x][y]
                }
            }
            //drawmap(icanvas,x,y,w,h)
            this.sw3 = (screenwidth*.20)
            this.sh3 = 300

            this.x3 = (screenwidth)-(this.sw3*2)
            //console.log(this.x3)
            this.y3 = (screenheight*.25)//100
            this.w3 = 300
            this.h3 = 300
            this.m3 = create2DArray(this.w3,this.h3)
            var m = new map(this.sw3,this.sh3,this.w3,this.h3,false)
            for(var x = 0;x<this.w3;x+=1){
                for(var y = 0;y<this.h3;y+=1){
                    this.m3[x][y] = m.mapfinal[x][y]
                }
            }
            //drawmap(icanvas,x,y,w,h)		
            //icanvas.Flush()		
        }
        update(){
            
            //if(Controller..KeyReleased(Key.Escape) Then App.Terminate()	
            if(this.delay<this.maxDelay)this.delay+=1
            if(this.delay+1>=this.maxDelay && Controller.Left==true){
                this.index-=1;
                this.delay=0
            }
            if(this.delay+1>=this.maxDelay && Controller.Right==true){
                this.index+=1;
                this.delay=0
            }
            if(this.index<0)this.index = 0
            if(this.index>2)this.index = 2
            if(Controller.ShotGun==true){
                if(this.index==0){
                    mapwidth = 150
                    mapheight = 150
                }
                if(this.index==1){
                    mapwidth = 250
                    mapheight = 250
                }
                if(this.index==2){
                    mapwidth = 300
                    mapheight = 300
                }
                //resetmap(screenwidth,screenheight)
                gamestate="setup"			
            }
        }
        draw(){
            //canvas.DrawImage(image,0,0)
            ctx2.fillStyle='white'
            ctx2.save()
            var msc = 2
            if(screenwidth<1000)msc=1.3
            ctx2.scale(msc,msc)
            ctx2.fillText("Use Cursor left and Right to select Button(fire) to Play",0,10)
            ctx2.fillText("Toggle Fullscreen<return>",screenwidth/msc-200,10)
            ctx2.restore()
            //
            //
            // Background ui

            var cornerSizeV = (screenheight) / 16
            var cornerSizeH = (screenwidth) / 16
            var top = screenheight*.1
            var bottom = screenheight*.63
            var right = screenwidth-32
            ctx2.scale(1,1)
            ctx2.fillStyle = 'rgb(10,10,40)';
            //ctx2.globalAlpha = 0.5
            ctx2.beginPath();
            ctx2.moveTo(cornerSizeH,top+cornerSizeV);
            ctx2.lineTo(right-cornerSizeH*2,top+cornerSizeV);
            ctx2.lineTo(right-50,top+cornerSizeV*2)
            ctx2.lineTo(right-50,bottom-cornerSizeV)
            ctx2.lineTo(right-50-cornerSizeH,bottom)
            ctx2.lineTo(cornerSizeH,bottom)
            ctx2.lineTo(0,bottom-cornerSizeV)
            ctx2.lineTo(0,top+cornerSizeV*2)
            ctx2.closePath();
            ctx2.globalAlpha = 0.3
            ctx2.fill();      
            ctx2.globalAlpha = 1    
            ctx2.strokeStyle = 'rgb(255,0,0)'
            ctx2.lineWidth = 6
            ctx2.stroke()
            ctx2.strokeStyle = 'rgb(255,255,255)'
            ctx2.lineWidth = 1
            ctx2.stroke()

            ctx2.globalAlpha = 1 
            //canvas.DrawText("Use Cursor left and Right to select Enter to Play",0,0)
            //canvas.PushMatrix()
            //canvas.Scale(2,2)
            //canvas.DrawText("Select Difficulty",400/2,50/2,.5,.5)
            //canvas.PopMatrix()
            //canvas.Color = Color.Yellow

            //
            //
            //
            var x=this.x1
            //var x=0
            var y=(screenheight*.25)//100
            var w=(screenwidth*.20)//this.sw1
            var h=150
            h = ((screenheight/3.3)/150)*150
            if(this.index == 0){ 
                this.mydrawrect(x,y,w,h)
                this.mydrawrect(x+1,y+1,w-2,h-2)
                ctx2.globalAlpha = 0.2
                ctx2.fillStyle = 'white'
                ctx2.fillRect(x,y,w,h)
                ctx2.globalAlpha = 1
            }
            x = this.x2
            //var x=screenwidth*.3
            y = (screenheight*.25)//100
            w = this.sw2
            var w=(screenwidth*.20)//this.sw1
            
            h = 250
            h = ((screenheight/3.3)/250)*250
            if(this.index == 1){ 
                this.mydrawrect(x,y,w,h)
                this.mydrawrect(x+1,y+1,w-2,h-2)
                ctx2.globalAlpha = 0.2
                ctx2.fillStyle = 'white'
                ctx2.fillRect(x,y,w,h)
                ctx2.globalAlpha = 1
            }
            x = this.x3
            //x = screenwidth-this.sw3
            y = (screenheight*.25)//100
            w = this.sw3
            var w=(screenwidth*.20)//this.sw1

            h = 300
            h = (screenheight/3.3/300)*300
            if(this.index == 2){ 
                this.mydrawrect(x,y,w,h)
                this.mydrawrect(x+1,y+1,w-2,h-2)
                ctx2.globalAlpha = 0.2
                ctx2.fillStyle = 'white'
                ctx2.fillRect(x,y,w,h)
                ctx2.globalAlpha = 1

            }
        }
        drawmap(){
            ctx2.globalAlpha = 1
            ctx2.fillStyle='black'
            ctx2.fillRect(0,0,screenwidth,screenheight)

     


            var x,y,w,h
            var tw,th
            for(var i=0;i<3;i+=1){
                if(i==0){
                    x = this.x1
                    y = this.y1
                    w = this.w1
                    h = this.h1
                    tw = this.sw1/this.w1

                    th=1
                    th=screenheight/3.3/150
                    tw=screenwidth/5/150
                }
                if(i==1){
                    x = this.x2
                    y = this.y2
                    w = this.w2
                    h = this.h2
                    tw =  this.sw2/w
                    th=1
                    tw=screenwidth/5/250

                    th=screenheight/3.3/250
                }
                if(i==2){
                    x = this.x3
                    y = this.y3
                    w = this.w3
                    h = this.h3
                    tw = this.sw3/this.w3
                    th=1
                    tw=screenwidth/5/300
                    th = screenheight/3.3/300
                }
                ctx2.fillStyle = 'rgb(4,3,30)'
                ctx2.fillRect(x+(0*tw),y+(0*th),w*tw+1,h*th+1)

                for(var y1=0;y1<h;y1+=1){
                    for(var x1=0;x1<w;x1+=1){
                        var a;
                        if(i==0)a = this.m1[x1][y1]
                        if(i==1)a = this.m2[x1][y1]
                        if(i==2)a = this.m3[x1][y1]
                        if(a==1){
                            ctx2.fillStyle = 'rgb(255,255,255)'
                            ctx2.fillRect(x+(x1*tw),y+(y1*th),th+1,tw+1)
                        }
//                        if(a!=1){
                            //ctx2.fillStyle = 'black'
                            //ctx2.fillRect(x+(x1*tw),y+(y1*th),th+1,th+1)
//                        }

                    }
                }
            }
        }
        mydrawrect(x,y,w,h){

            drawLine(x,y,x+w,y,'yellow',3,ctx2)
            drawLine(x+w,y,x+w,y+h,'yellow',3,ctx2)
            drawLine(x,y,x,y+h,'yellow',3,ctx2)
            drawLine(x,y+h,x+w,y+h,'yellow',3,ctx2)
        }
    }

    //
    // The tentacle for the growing slime monster
    //
    class tentacle{

        constructor(basex,basey,targetx,targety){
            this.basex,this.basey
            this.targetx,this.targety
            this.topx,this.topy
            this.angle
            this.mx,this.my
            this.speed = 14
            this.deleteme=false
            this.state = "outgoing"
            this.grabbed=false
            this.grabbedx
            this.grabbedy
            this.basex = basex
            this.basey = basey
            this.topx = basex
            this.topy = basey
            this.targetx = targetx
            this.targety = targety
            this.angle = getangle(basex,basey,targetx,targety)
            this.mx = Math.cos(this.angle)
            this.my = Math.sin(this.angle)
            
        }
        update(){
            if(this.speed > 1)this.speed -= .1;
            for(var movement=0;movement<this.speed;movement+=1){
                this.topx += this.mx
                this.topy += this.my
                if(this.state == "outgoing"){
                    //check collision with walkingmonster
                    for(var i=0;i<mywalkingmonster.length;i+=1){
                        var x=mywalkingmonster[i].px+(mywalkingmonster[i].w/2)
                        var y=mywalkingmonster[i].py+(mywalkingmonster[i].h/2)
                        if(distanceM(this.topx,this.topy,x,y) < 10){
                            this.topx = mywalkingmonster[i].px
                            this.topy = mywalkingmonster[i].py
                            this.angle = getangle(this.topx,this.topy,this.basex,this.basey)
                            this.mx = Math.cos(this.angle)
                            this.my = Math.sin(this.angle)
                            this.grabbed = true
                            this.state = "ingoing"
                            mywalkingmonster[i].deleteme = true
                            break						
                        }
                    }

                    //check collision with flyingmonster
                    for(var i=0;i<myflyingmonster.length;i+=1){
                        var x=myflyingmonster[i].px+(myflyingmonster[i].w/2)
                        var y=myflyingmonster[i].py+(myflyingmonster[i].h/2)
                        if(distanceM(this.topx,this.topy,x,y) < 10){
                            this.topx = myflyingmonster[i].px
                            this.topy = myflyingmonster[i].py
                            this.angle = getangle(this.topx,this.topy,this.basex,this.basey)
                            this.mx = Math.cos(this.angle)
                            this.my = Math.sin(this.angle)
                            this.grabbed = true
                            this.state = "ingoing"
                            myflyingmonster[i].deleteme = true
                            break
                        }
                    }
                    //check collision with player
                    var x=myplayer.px+(myplayer.pw/2)
                    var y=myplayer.py+(myplayer.ph/2)
                    if(developmode == false && distanceM(x,y,this.topx,this.topy) < 20){
                        this.mx = -this.mx
                        this.my = -this.my
                        this.state = "ingoing"
                        myplayer.hp -= 10
                        mynumberfall.push(
                                new numberfall(
                                    myplayer.px+(myplayer.pw/2),myplayer.py,10,'red'
                                    ) 
                        );
                        //mynumberfall.Add(New numberfall(myplayer.px+(myplayer.pw/2),myplayer.py,10,Color.Red))
                        if(myplayer.hp < 0){ 
                            gamestate = "select"
                            return
                        }
                    }
                }	
                if(this.state=="outgoing" && this.grabbed==false && distanceM(this.topx,this.topy,this.targetx,this.targety) < 10){ 
                        this.state = "ingoing"
                        this.mx = -this.mx
                        this.my = -this.my
                        return
                }
                if(this.state == "ingoing"){
                    if(distanceM(this.topx,this.topy,this.basex,this.basey) < 10){
                        this.deleteme = true
                        return
                    }
                }
            }
        }	
    }

    class growslime{
        constructor(){
            this.map
            this.w,this.h
            this.tw,this.th
            this.openx
            this.openy
            this.slimetile=10
            this.slimestartx,this.slimestarty

            this.w = Math.floor(mymap.mmw * 2)
            this.h = Math.floor(mymap.mmh * 2)
            this.tw = tilewidth/2//'mymap.tw * 2
            this.th = tileheight/2//'mymap.th * 2+2
            //map = New Int[w,h]
            this. map = create2DArray(this.w,this.h)
            //copy the map from the game into this map
            for(var y=0 ;y<mymap.mmh;y+=1){
                for(var x=0;x<mymap.mmw;x+=1){
                    for(var y2=0;y2<2;y2+=1){
                        for(var x2=0;x2<2;x2+=1){
                            this.map[(x*2)+x2][(y*2)+y2] = mymap.mapfinal[x][y]			
                        }
                    }
                }
            }
            //create the active slime list
            this.openx = []
            this.openy = []
            this.findslimestartpos()
            //console.log(this.slimestartx+","+this.slimestarty)
            this.openx.push(this.slimestartx)
            this.openy.push(this.slimestarty)
            this.openx.push(this.slimestartx)
            this.openy.push(this.slimestarty-1)
            this.openx.push(this.slimestartx+1)
            this.openy.push(this.slimestarty)

            this.map[this.slimestartx+1][this.slimestarty]=this.slimetile
            this.map[this.slimestartx][this.slimestarty-1]=this.slimetile
            this.map[this.slimestartx][this.slimestarty]=this.slimetile

        }
        findslimestartpos(){
            for(var y=this.h-1;y>=0;y-=1){
                for(var x=0;x<this.w;x+=1){
                    if(this.map[x][y] == mymap.tileempty){ 
                        this.slimestartx = Math.floor(x)
                        this.slimestarty = Math.floor(y)
                        return
                    }
                }
            }
        }
        remove(x,y){		
            this.map[x][y] = mymap.tileempty
            //drop gold from slime
            if(Math.random()<.1){
            myitem.push(
                new item(
                (x/2)*tilewidth,(y/2)*tileheight,"Gold"    

                ) 
            );
            }
            var rem=false
            var tmpx = []
            var tmpy = []
            for(var i=0;i<this.openx.length;i+=1){
                if(this.openx[i] == x && this.openy[i] == y){
                    //map[x,y] = mymap.tileempty
                    rem = true
                }else{
                    tmpx.push(x)
                    tmpy.push(y)
                }
            }
            if(rem == false)return
            this.openx = []
            this.openy = []
            for(var i=0;i<tmpx.length;i+=1){
                this.openx.push(tmpx[i])
                this.openy.push(tmpy[i])
            }
          
        }
        update(speed){
            if(developmode==true)speed = "fast"
            var freq
            if(speed == "slow"){
                freq = 120//120
            }else{
                freq = 1
            }
            
            //every now And then check if we can restore growth
            if(randomRange(0,1500) < 2){//1500
                for(var y=0;y<mymap.mmw*2;y+=1){
                    for(var x=0;x<mymap.mmh*2;x+=1){
                        if(mygrowslime.map[x][y] == mymap.tileslime){					
                            for(var i=0;i<this.openx.length;i+=1){
                                if(this.openx[i] == x && this.openy[i] == y)continue
                            }					
                            var cnt=0
                            for(var y2=y-1;y2<=y+1;y2+=1){
                                for(var x2=x-1;x2<=x+1;x2+=1){
                                    if(mygrowslime.map[x2][y2] == mymap.tileempty){
                                        cnt+=1
                                    }
                                }
                            }
                            if(cnt<9){
                                this.addslime(x,y)
                            }					
                        }
                    }
                }
            }
            
            // Tentacle check
            // Every now and then check if active slime part is in range
            // of player/enemy and then check if path is clear and if so
            // then initiate tentacle.
            // Grab player
            for(var i=0;i<this.openx.length;i+=1){
                var x1 = this.openx[i] * (myplayer.tw/2)
                var y1 = this.openy[i] * (myplayer.th/2)
                var pcx = myplayer.px+(myplayer.pw/2)
                var pcy = myplayer.py+(myplayer.ph/2)
                // grab walking monster
                if(randomRange(0,300) < 2){
                    for(var i2=0;i2<mywalkingmonster.length;i2+=1){
                        var mcx=mywalkingmonster[i2].px+(mywalkingmonster[i2].w/2)
                        var mcy=mywalkingmonster[i2].py+(mywalkingmonster[i2].h/2)
                        if(distanceM(mcx,mcy,x1,y1) < 200){
                            var an = getangle(x1,y1,mcx,mcy)
                            var mx = Math.cos(an)
                            var my = Math.sin(an)
                            var x2 = x1
                            var y2 = y1
                            for(var i3=0;i3<200;i3+=1){
                                x2 += mx
                                y2 += my
                                if(mymap.mapcollide(x2,y2,mywalkingmonster[i2].w,mywalkingmonster[i2].h) == true){
                                    break
                                }
                                if(distanceM(x2,y2,mcx,mcy) < 50){
                                    //NOTE:
                                    //mytentacle.Add(New tentacle(x1,y1,mcx,mcy))	
                                    mytentacle.push(
                                        new tentacle(
                                            x1,y1,mcx,mcy
                                            ) 
                                    );				
                                    break
                                }
                            }
                            break
                        }
                    }
                }

                // grab monster
                if(randomRange(0,300) < 2){
                    for(var i2=0;i2<myflyingmonster.length;i2+=1){
                        var mcx=myflyingmonster[i2].px+(myflyingmonster[i2].w/2)
                        var mcy=myflyingmonster[i2].py+(myflyingmonster[i2].h/2)
                        if(distanceM(mcx,mcy,x1,y1) < 200){
                            var an = getangle(x1,y1,mcx,mcy)
                            var mx = Math.cos(an)
                            var my = Math.sin(an)
                            var x2 = x1
                            var y2 = y1
                            for(var i3=0;i3<200;i3+=1){
                                x2 += mx
                                y2 += my
                                if(mymap.mapcollide(x2,y2,myflyingmonster[i2].w,myflyingmonster[i2].h) == true){
                                    break
                                }
                                if(distanceM(x2,y2,mcx,mcy) < 50){
                                    //NOTE:
                                    //mytentacle.Add(New tentacle(x1,y1,mcx,mcy))	
                                    mytentacle.push(
                                        new tentacle(
                                            x1,y1,mcx,mcy
                                            ) 
                                    );				
                                    break
                                }
                            }
                            break
                        }
                    }
                }
                //grab player
                if(randomRange(0,300)<2 && distanceM(pcx,pcy,x1,y1) < 200){ 
                    var an = getangle(x1,y1,pcx,pcy)
                    var mx = Math.cos(an)
                    var my = Math.sin(an)
                    var x2 = x1
                    var y2 = y1
                    for(var i2=0;i2<200;i2+=1){
                        x2 += mx
                        y2 += my
                        if(mymap.mapcollide(x2,y2,myplayer.pw,myplayer.ph) == true){
                            break
                        }
                        if(distanceM(x2,y2,pcx,pcy) < 50){
                            //NOTE:
                            //mytentacle.Add(New tentacle(x1,y1,pcx,pcy))	
                            mytentacle.push(
                                new tentacle(
                                    x1,y1,pcx,pcy
                                    ) 
                                );				
                            break
                        }
                    }
                    break
                }			
            }


            
            // Expand Slime		
            for(var i=0;i<this.openx.length;i+=1){
                if(randomRangeFloat(0,freq) > 2)continue
                
                var x2=this.openx[i]
                var y2=this.openy[i]

        

                //bottom bleft or bright first
                var r=randomRange(0,6)
                if(this.map[x2][y2+1]==1){
                    this.addslime(x2,y2+2)
                }
                if(r==0 && y2+1<this.h && this.map[x2][y2+1] == 1){
                    this.addslime(x2,y2+1)
                    continue
                }
                if(r==1 && x2-1 >=0 && y2+1 <this.h && this.map[x2-1][y2+1] == 1){
                    this.addslime(x2-1,y2+1)
                    continue
                }
                if(r==2 && y2+1<this.h && this.map[x2+1][y2+1] == 1){
                    this.addslime(x2+1,y2+1)

                    continue
                }
                // left Or right Then
                r = randomRange(0,2)
                if(r==0 && x2-1>=0 && this.map[x2-1][y2] == 1){
                    this.addslime(x2-1,y2)
                    continue
                }
                if(r==1 && x2+1<this.w && this.map[x2+1][y2] == 1){
                    this.addslime(x2+1,y2)
                    continue
                }
                // up lup and rup
                r = randomRange(0,23)
                if(r==0 && y2-1>=0 && this.map[x2][y2-1] == 1){
                    this.addslime(x2,y2-1)
                    continue
                }
                if(r==1 && x2-1>=0 && y2-1>=0 && this.map[x2-1][y2-1] == 1){
                    this.addslime(x2-1,y2-1)
                    continue
                }
                if(r==2 && x2+1<this.w && y2-1>=0 && this.map[x2+1][y2-1] == 1){
                    this.addslime(x2+1,y2-1)
                    continue
                }
            }
            
            var tx=[]
            var ty=[]
            // Remove Obsolete slime
            
            for(var i=0;i<this.openx.length;i+=1){
                var cnt=0
                for(var y=-1;y<=1;y+=1){
                    for(var x=-1;x<=1;x+=1){
                        var x2=this.openx[i]+x
                        var y2=this.openy[i]+y
                        
                        if(x2<0 || y2<0 || x2>=this.w || y2>=this.h){
                            cnt+=1
                            continue
                        }				
                        if(this.map[x2][y2] == 10)cnt+=1
                        if(this.map[x2][y2] == 0)cnt+=1
                        //if(this.map[x2][y2] != mymap.tileempty)cnt+=1
                        
                        //if map[x2,y2] = 1 Then cnt+=1
                        //If map[x2,y2] <> 1 Then cnt+=1
                    }
                }		
                if(cnt==9){
                    //openx.Remove(i)
                    //openy.Remove(i)
                    }else{// if( this.map[this.openx[i]][this.openy[i]] == mymap.tileempty ){
                        tx.push(this.openx[i])
                        ty.push(this.openy[i])
                    }
                
            }
            this.openx = []
            this.openy = []
            for(var i=0;i<tx.length;i+=1){
                this.openx.push(tx[i])
                this.openy.push(ty[i])
            }
            
            /*
            // Remove open slime where no slimetiles are underneath
            tx = []
            ty = []
            for(var i=0;i<this.openx.length;i+=1){
                if(this.map[this.openx[i]][this.openy[i]] == this.slimetile){
                    tx.push(this.openx[i])
                    ty.push(this.openy[i])
                    }else{
                }
            }
            this.openx = []
            this.openy = []
            for(var i=0;i<tx.length;i+=1){
                this.openx.push(tx[i])
                this.openy.push(ty[i])
            }
            */
        }

        slimecollide(x,y,w,h,remove){
            if(remove == true && randomRange(0,20) > 2)remove=false
            var mmw=mymap.mmw
            var mmh=mymap.mmh
            var lefttopx		=Math.floor(((x)/tilewidth))
            var lefttopy		=Math.floor(((y)/tileheight))
            var righttopx		=Math.floor(((x+w)/tilewidth))
            var righttopy		=Math.floor(((y)/tileheight))
            var leftbottomx	    =Math.floor(((x)/tilewidth))
            var leftbottomy	    =Math.floor(((y+h)/tileheight))
            var rightbottomx	=Math.floor(((x+w)/tilewidth))												
            var rightbottomy	=Math.floor(((y+h)/tileheight))
            //
            //		If lefttopx < 0 Or lefttopx >= mmw Then return True
            //		If lefttopy < 0 Or lefttopy >= mmh Then return True
            //		If righttopx < 0 Or righttopx >= mmw Then return True
            //		If righttopy < 0 Or righttopy >= mmh Then return True
            //		If leftbottomx < 0 Or leftbottomx >= mmw Then return True
            //		If leftbottomy < 0 Or leftbottomy >= mmh Then return True
            //		If rightbottomx < 0 Or rightbottomx >= mmw Then return True
            //		If rightbottomy < 0 Or rightbottomy >= mmh Then return True
            //	
            for(var y2=0;y2<=1;y2+=1){
            for(var x2=0;x2<=1;x2+=1){
                    if(mygrowslime.map[lefttopx*2+x2][lefttopy*2+y2] == mymap.tileslime){	
                        if(remove == true){				
                            this.removeslime(lefttopx*2+x2,lefttopy*2+y2)
                        }
                        return true
                    }
                    if(mygrowslime.map[righttopx*2+x2][righttopy*2+y2] == mymap.tileslime){			
                        if(remove == true){
                            this.removeslime(righttopx*2+x2,righttopy*2+y2)
                        }
                        return true
                    }
                    if(mygrowslime.map[leftbottomx*2+x2][leftbottomy*2+y2] == mymap.tileslime){			
                        if(remove == true){
                            this.removeslime(leftbottomx*2+x2,leftbottomy*2+y2)
                        }
                        return true
                    }
                    if(mygrowslime.map[rightbottomx*2+x2][rightbottomy*2+y2] == mymap.tileslime){			
                        if(remove == true){
                            this.removeslime(rightbottomx*2+x2,rightbottomy*2+y2)
                        }
                        return true						
                    }
                }
            }
                return false
        }	
        removeslime(x,y){
            for(var y2=y-1;y2<=y+1;y2+=1){
                for(var x2=x-1;x2<=x+1;x2+=1){
                    mygrowslime.remove(x2,y2)
                }
            }
            

            
            
        }

        addslime(sx,sy){
            //var a=0
            //if(mymap.mapcollide((((sx)+1*tilewidth)/2),(((sy)+1*tileheight)/2),tilewidth/2,tileheight/2))a+=1
            if(mymap.mapcollide(((sx*tilewidth)/2),((sy*tileheight)/2),tilewidth/3,tileheight/3))return
            //if(a==1)return
            //if(mymap.mapcollide(((sx*tilewidth)/2),((sy*tileheight)/2),tilewidth/2,tileheight/2))return 
                       //console.log("add slime here:"+sx+","+sy)
            this.openx.push(sx)
            this.openy.push(sy)
            //console.log(this.map[sx][sy])
            if(this.map[sx][sy]==mymap.tileempty)this.map[sx][sy] = this.slimetile
            //console.log("z")
        }

        drawmap(){
            ctx2.save()
            ctx2.scale(.7,.7)
            ctx2.translate(screenwidth*.15,screenheight*.15)            
            // Draw the solid slimes ()
            for(var y=0;y<this.h;y+=1){
                for(var x=0;x<this.w;x+=1){
                    var x1=x*mymap.tw/2
                    var y1=y*mymap.th/2
                    if(this.map[x][y] == this.slimetile){
                        //console.log("a")
                        ctx2.fillStyle='green'
                        ctx2.fillRect(x1,y1,mymap.tw/2,mymap.th/2)
                        //canvas.Color = Color.Green
                        //canvas.DrawRect(x1,y1,mymap.tw/2,mymap.th/2)
                    }            
                }
            }
            ctx2.restore()
            ctx2.scale(1,1)

        }	
    }

    //'
    //' Drop a number from a x,y position
    //' 
    class numberfall{
        constructor(x,y,number,col){
            this.px,this.py
            this.number
            this.col
            this.mx
            this.my
            this.time //' if 0 then remove
            this.deleteme=false

            this.px = x
            this.py = y
            this.number = number
            this.col = col
            this.time = 80
            this.mx = randomRangeFloat(-1,1)
            this.my = -2
        }
        update(){
            this.my += .17
            this.px += this.mx
            this.py += this.my
            this.time-=1
            if(this.time<=0)this.deleteme = true
        }
    }
    //'
    //
    // These are the walking monsters that
    // hatch from the eggs. They do not lay eggs
    // themselfs but guard the other nearby eggs.
    //
    class walkingmonster{
 
        constructor(x,y){
            this.px,this.py //pixel position (0-width)
            this.sx,this.sy //movement speed
            this.x,y //tile x and y position
            this.w,this.h
            this.hp //hitpoints
            this.hpmax
            this.deleteme
            this.state
            this.substate
            this.jx
            this.jy
            this.oldpy //old py coordinate
            this.x = x
            this.y = y
            this.w = tilewidth
            this.h = tileheight
            this.px = x*this.w
            this.py = y*this.h
            this.hp = randomRange(10,30)
            this.hpmax = this.hp
            this.direction = "left"
            this.inRange = true
            this.inRangeCnt = 0
            this.inRangeCntMax = 30
            this.animationFacing = "left"
            //set the movement speed
            this.sx = randomRangeFloat(0.3,3)
            //sy = sx
            this.state="hatched"

            this.frame = 20
            this.animationMode = "pingpong" 
            this.animation = [20,21,22]
            this.animationTime = [10,10,10]
            this.animationIndex = 0
            this.animationDirection = 1
            this.animationCurrentTime = 0
        }
        setwWalkAnimation(){
            this.frame = 20
            this.animationMode = "pingpong" 
            this.animation = [20,21,22]
            this.animationTime = [10,10,10]
            this.animationIndex = 0
            this.animationDirection = 1
            this.animationCurrentTime = 0
        }
        setjumpAnimation(){
            this.frame = 23
            this.animationMode = "playonce" 
            this.animation = [23,24,25]
            this.animationTime = [7,7,111]
            this.animationIndex = 0
            this.animationDirection = 1
            this.animationCurrentTime = 0
        }
        setLandAnimation(){
            this.frame = 26
            this.animationMode = "playonce" 
            this.animation = [26,27]
            this.animationTime = [20,10000]
            this.animationIndex = 0
            this.animationDirection = 1
            this.animationCurrentTime = 0
        }
        update(){		

            // Sprite Animation system
            //
            this.animationCurrentTime+=1
            //console.log(this.animationIndex)
            if(this.animationCurrentTime>=this.animationTime[this.animationIndex]){
                this.animationCurrentTime = 0
                this.animationIndex+=this.animationDirection
                if(this.animationIndex==this.animation.length-1){
                    //this.animationIndex = 0
                    if(this.animationMode=="pingpong"){
                        this.animationDirection = -1
                    }
                    if(this.animationMode=="playonce"){
                        this.animationDirection = 0
                        this.frame=25
                    }
                }
                if(this.animationIndex==0){
                    if(this.animationMode=="pingpong"){
                        this.animationDirection = 1
                    }
                }
                //if(this.animation[this.animationIndex]==25)console.log("ewerwer")
                this.frame = this.animation[this.animationIndex]
                
            }

            this.inRangeCnt+=1
            if(this.inRangeCnt>this.inRangeCntMax){
                this.inRangeCnt = 0;
                if(distanceM(myplayer.px,myplayer.py,this.px,this.py)>drawDistance){
                    this.inRange=false
                }else{
                    this.inRange=true
                }
            }
            //If laserwait>0 Then laserwait-=1
        
            // Damage to player
            if(developmode == false){
                if(distanceM(   myplayer.px+(myplayer.pw/2),myplayer.py+(myplayer.ph/2),
                                this.px+(this.w/2),this.py+(this.h/2)) < tilewidth){
                    myplayer.hp -= 2
                    mynumberfall.push(
                        new numberfall(
                            myplayer.px+(myplayer.pw/2),myplayer.py,2,'red'
                            ) 
                    );
                    //mynumberfall.Add(New numberfall(myplayer.px+(myplayer.pw/2),myplayer.py,2,Color.Red))
                    if(myplayer.hp < 0)gamestate = "select"
                }
            }
            // bug fix solution : substate gets stuck in finishjump in roam
            if(this.state=="roam" && this.substate=="finishjump"){
                this.substate="left"
                if(Math.random()<.5)this.substate="right"
                this.animationFacing=this.substate
            }
            // ttak
            if(this.state!="attack"){
                //If Rnd(10)<1 Print Millisecs() + "sx : " + sx
                if(this.px < this.x*this.w)this.px += this.sx
                if(this.px > this.x*this.w)this.px -= this.sx
                //		If py < y*h)py += sy
                //		If py > y*h)py -= sy
                if(this.laserwall())this.changedirection()
                if(distanceM(this.px,this.py,this.x*this.w,this.y*this.h) > 8)return
                }else{
                if(this.substate == "jump"){
                    if(mymap.mapcollide(this.px+this.jx,this.py,this.w,this.h) == false){
                        this.px += this.jx
                    }else{
                        //substate = "finishjump"				
                    }
                    if(mymap.mapcollide(this.px,this.py+this.jy,this.w,this.h-1) == false){
                        this.py += this.jy
                    }else{
                        this.x = myplayer.px / tilewidth
                        this.y = myplayer.py / tileheight
                        this.substate = "finishjump"
                        return
                    }
                    this.jy += .1
                    this.x = this.px / tilewidth
                    this.y = this.py / tileheight
                }
            }
            if(this.state=="hatched"){
                //Case "hatched"
                this.state="roam"
                this.substate="left"
                if(Math.random()<.5)this.substate="right"
                this.animationFacing = this.substate
            }
            if(this.state=="attack"){
                //Case "attack"
 

                if(this.substate=="setjump"){
                    this.setjumpAnimation()
                    //Case "setjump"
                    if(myplayer.py < this.py){
                        this.substate="finishjump"
                        
                    }
                    if(myplayer.py > this.py+3){
                        this.substate="finishjump"
                        
                    }
                    var d=distanceM(myplayer.px,myplayer.py,this.px,this.py)
                    if(this.px < myplayer.px){
                        this.jx = d/35
                        }else{
                        this.jx = -d/35
                    }
                    
                    if(distanceM(this.px,this.py,myplayer.px,myplayer.py) > 50){
                        this.jy = -2
                    }else{
                        //this.setLandAnimation()
                    }
                    // face into the direction of the player when we jump
                    this.substate = "jump"
                    this.animationFacing="right"
                    if(this.px>myplayer.px)this.animationFacing="left"
                    return
                }
                if(this.substate=="jump"){
                    //Case "jump"
                    //						
                    var cnt=0
                    for(var ppy=0;ppy<40;ppy+=1){
                        if(mymap.mapcollide(this.px+(this.jx*10),this.py+ppy,this.w,this.h) == false)cnt+=1
                    }
                    if(cnt>30)this.jx=-this.jx
                }
                if(this.substate=="finishjump"){
                    this.setwWalkAnimation()
                    //Case "finishjump"
                    this.state = "roam"
                    this.x = this.px / tilewidth
                    this.y = this.py / tileheight
                    if(Math.random()< .5){
                        this.substate == "left"
                        this.animationFacing = this.substate
                        }else{
                        this.substate="right"	                        
                        this.animationFacing = this.substate
                    }					
                }//End Select	

            }
            if(this.state=="roam"){
                //Case "roam"								
                if(this.canattackplayer()){
                    this.state="attack"
                    this.substate="setjump"
                }
                  
                if(this.substate=="left"){
                    //Case "left"
                    this.x-=1
                    //If Rnd(50) < 1 And mymap.mapfinal[x-1,y] = mymap.tileempty And mymap.mapfinal[x-1,y+1] <> mymap.tileempty Then substate="right"						
                    //If Rnd(50) < 1 And cannotgohere(x+1,y) = false And cannotgohere(x+1,y+1)=true Then substate="right" 
                    if(this.cannotgohere(this.x-1,this.y) == true){
                        this.substate = "right"
                        this.animationFacing = this.substate
                    }
                    if(this.cannotgohere(this.x-1,this.y+1) == false){
                        this.substate = "right"
                        this.animationFacing = this.substate
                    }
                    //If mymap.mapfinal[x-1,y]  <> mymap.tileempty Then substate="right"
                    //If mymap.mapfinal[x-1,y+1] = mymap.tileempty Then substate="right"
                    if(this.x<3){
                        this.substate="right"
                        this.animationFacing = this.substate
                    }
                }
                if(this.substate=="right"){        
                    //Case "right"						
                    this.x+=1
                    //If Rnd(50) < 1 And cannotgohere(x-1,y) =  false And cannotgohere(x-1,y+1)=true Then substate="left"
                    if(this.cannotgohere(this.x+1,this.y) == true){
                        this.substate="left"
                        this.animationFacing = this.substate
                    }
                    if(this.cannotgohere(this.x+1,this.y+1) == false){
                        this.substate="left"
                        this.animationFacing = this.substate
                    }
                    //If Rnd(50) < 1 And mymap.mapfinal[x+1,y] = mymap.tileempty And mymap.mapfinal[x+1,y+1] <> mymap.tileempty Then substate="left"						
                    //If mymap.mapfinal[x+1,y]  <> mymap.tileempty Then substate="left"
                    //If mymap.mapfinal[x+1,y+1] = mymap.tileempty Then substate="left"
                    if(this.x>mapwidth-3){
                        this.substate=="left"
                        this.animationFacing = this.substate
                    }
                }//End Select

                    //gorandleftorright()
            }
            //console.log(this.state+","+this.substate)
        }


        canattackplayer(){
            
            if(distanceM(this.px,this.py,myplayer.px,myplayer.py) > 150)return false
            
            if(myplayer.px < this.px){
                for(var xx=this.px/tilewidth;xx>this.px/tilewidth-3;xx-=1){
                    if(mymap.mapfinal[Math.floor(xx)][this.y+1] != mymap.tilesolid)return false
                }
            }else{
                for(var xx=this.px/tilewidth;xx<this.px/tilewidth+3;xx+=1){
                    if(mymap.mapfinal[Math.floor(xx)][this.y+1] != mymap.tilesolid)return false
                }			
            }
            
            var angle = getangle(this.px,this.py,myplayer.px,myplayer.py)
            var clearpath=false
            var mx = Math.cos(angle)
            var my = Math.sin(angle)
            var monx = this.px
            var mony = this.py
            for(var i=0;i<200;i+=1){
                monx += mx
                mony += my
                if(distanceM(monx,mony,myplayer.px,myplayer.py) < 20)return true
                if(mymap.mapcollide(monx,mony,this.w/2,this.h/2) == true)return false	
                if(this.collidelaserwall(monx,mony,this.w,this.h))return false
            }			
            return true
        }	
        // for the walking monster Check if(tile on map is blocked
        cannotgohere(x,y){
            x = Math.floor(x)
            y = Math.floor(y)
            if(mymap.mapfinal[x][y] == mymap.tilesolid)return true
            if(mymap.mapfinal[x][y] == mymap.tilemineable)return true
            if(mymap.mapfinal[x][y] == mymap.tileturret)return true
            return false

        }
        collidelaserwall(x,y,w1,h1){
        
            
            for(var i=0;i<mylaserwall.length;i+=1){
                if(rectsoverlap((x-w1)+(randomRangeFloat(-w1,w1)),y-h1,w1*2,
                                h1*2,mylaserwall[i].tx-5,mylaserwall[i].ty,10,mylaserwall[i].by-mylaserwall[i].ty)){
                    return true
                } 
            }
            return false
            
        }
        laserwall(){
            //return false;
            
            for(var i=0;i<mylaserwall.length;i+=1){
                if(rectsoverlap(    (this.px-this.w)+(randomRangeFloat(-this.w,this.w)),
                                    this.py-this.h,this.w*2,this.h*2,
                                    mylaserwall[i].tx-5,mylaserwall[i].ty,10,mylaserwall[i].by-mylaserwall[i].ty)){
                    return true
                } 
        }
            return false
            
        }
        changedirection(){
            this.state = "roam"
            if(this.substate == "left"){
                this.substate="right" 
                this.x += 2		
                }else{
                this.substate="left"
                this.x -= 2
            }
        }	
        draw(){
            var x1=(screenwidth-48)/mapwidth*this.x
            var y1=(screenheight-48)/mapheight*this.y
            ctx.fillStyle = 'white'
            ctx.fillRect(x1,y1,3+2,3+2)
            ctx.fillStyle = 'blue'
            ctx.fillRect(x1+1,y1+1,3,3)
            //canvas.Color = Color.White
            //SetColor 255,255,255
            //canvas.DrawRect(x1,y1,3+2,3+2)
            //canvas.Color = Color.Red
            //SetColor 255,0,0		
            //canvas.DrawRect(x1+1,y1+1,3,3)
        
        }

    }




    //uses myflyingmonster
    class turret{
        constructor(){
            this.deleteme
            this.mapx,this.mapy 
            this.tw,this.th //'tilewidht and height
            this.owner="town"
            this.findstartposition()
            this.tw = tilewidth
            this.th = tileheight
        }
        update(){
            if(myflyingmonster.length==0)return
            if(randomRange(20)<10)return
            for(var i=0;i<myflyingmonster.length;i++){		
                //if(Math.random()<0.01)console.log(distanceM(this.mapx,this.mapy,myflyingmonster[i].x,myflyingmonster[i].y))
                if(distanceM(this.mapx,this.mapy,myflyingmonster[i].x,myflyingmonster[i].y) > 15)continue
                //'if distance is close by
                if( this.clearshot(this.mapx*this.tw,this.mapy*this.th,
                        getangle(this.mapx*this.tw,this.mapy*this.th,
                        myflyingmonster[i].x*this.tw,myflyingmonster[i].y*this.th)+randomRangeFloat(-.2,.2))==true ){
                    mybullet.push(
                        new bullet(
                            this.mapx*this.tw,this.mapy*this.th,
                            getangle(this.mapx*this.tw,this.mapy*this.th,
                                    myflyingmonster[i].x*this.tw,
                                    myflyingmonster[i].y*this.th)+randomRangeFloat(-.2,.2),
                            "town","turret"
                            )
                    );
                    //mybullet.AddLast(New bullet(mapx*tw,mapy*th,getangle(mapx*tw,mapy*th,i.x*tw,i.y*th)+Rnd(-.2,.2),"town","turret"))
                }
            }

            for(var i=0;i<myflyingmonster.length;i++){	
                //if(Math.random()<0.01)console.log(distanceM(this.mapx,this.mapy,i.x,i.y))
                if(distanceM(this.mapx,this.mapy,myflyingmonster[i].x,myflyingmonster[i].y) > 15)continue
                //'if distance is close by
                if(this.clearshot(this.mapx*this.tw,this.mapy*this.th,
                        getangle(this.mapx*this.tw,this.mapy*this.th,
                                myflyingmonster[i].x*this.tw,myflyingmonster[i].y*this.th)+randomRangeFloat(-.2,.2))){
                   mybullet.push(
                        new bullet(
                            this.mapx*this.tw,this.mapy*this.th,
                            getangle(this.mapx*this.tw,this.mapy*this.th,
                                    myflyingmonster[i].x*this.tw,myflyingmonster[i].y*this.th)+randomRangeFloat(-.2,.2),
                            "town","turret"
                            )
                    );
                    //mybullet.AddLast(New bullet(mapx*tw,mapy*th,getangle(mapx*tw,mapy*th,i.x*tw,i.y*th)+Rnd(-.2,.2),"town","turret"))
                }
            }
        }
        //' Check if we are not recklessly shooting into a solid tile
        clearshot(x,y,angle){
            for(var i=0;i<100;i++){
                x+=Math.cos(angle)
                y+=Math.sin(angle)
                if(mymap.mapcollide2(x,y,3,3))return false
            }
            return true
        }
        findstartposition(){
            //' position on the left side
            for(var y=2;y< mymap.mmh-2;y++){
            for(var x=2;x< mymap.mmw-2;x++){
                if(mymap.mapfinal[x][y] == mymap.tileempty){
                if(mymap.mapfinal[x+1][y] == mymap.tileempty){
                if(mymap.mapfinal[x+1][y+1] == mymap.tileempty){
                if(mymap.mapfinal[x][y+1] == mymap.tilesolid){				
                    if(mymap.mapfinal[x-1][y] == mymap.tileempty){					
                        mymap.mapfinal[x-1][y] = mymap.tileturret
                        this.mapx = x - 1
                        this.mapy = y
                        return
                     }else if(mymap.mapfinal[x+5][y] == mymap.tileempty){
                        mymap.mapfinal[x+5][y] = mymap.tileturret
                        this.mapx = x + 5
                        this.mapy = y
                        return
                     }else{ //' no place for turret
                        this.deleteme = true					
                        return
                    }
                }
                }
                }
                }
            }
            }
        }     
    }

    class theflyingmonster{
        constructor(x,y){
            this.px,this.py //pixel position (0-width)
            this.sx,this.sy //movement speed
            this.x,this.y //tile x and y position
            this.w,this.h
            this.hp //hitpoints
            this.hpmax
            this.deleteme
            this.state
            this.substate

            this.inRange = true // should he be drawn
            this.inRangeCnt = 0
            this.inRangeCntMax = 30

            this.x = x
            this.y = y
            this.w = tilewidth
            this.h = tileheight
            this.px = x*this.w
            this.py = y*this.h
            this.hp = randomRange(10,30)
            this.hpmax = this.hp
            //set the movement speed
            this.sx = randomRangeFloat(0.3,3)
            this.sy = this.sx;
            this.state="hatched"


            this.animationFacing = "right"
            this.frame = 40
            this.animationMode = "pingpong" 
            this.animation = [40,41,42]
            this.animationTime = [10,10,10]
            this.animationIndex = 0
            this.animationDirection = 1
            this.animationCurrentTime = 0
        }
        setFrontFlyAnimation(){
            this.frame = 40
            this.animationMode = "pingpong" 
            this.animation = [40,41,42]
            this.animationTime = [10,10,10]
            this.animationIndex = 0
            this.animationDirection = 1
            this.animationCurrentTime = 0
        }
        setSideFlyAnimation(){
            this.frame = 43
            this.animationMode = "pingpong" 
            this.animation = [43,44,45]
            this.animationTime = [10,10,10]
            this.animationIndex = 0
            this.animationDirection = 1
            this.animationCurrentTime = 0
        }
        update(){
            // optimization
            this.inRangeCnt+=1
            if(this.inRangeCnt>this.inRangeCntMax){
                this.inRangeCnt = 0;
                if(distanceM(myplayer.px,myplayer.py,this.px,this.py)>drawDistance){
                    this.inRange=false
                }else{
                    this.inRange=true
                }
            }

            // Sprite Animation system
            //
            this.animationCurrentTime+=1
            //console.log(this.animationIndex)
             if(this.animationCurrentTime>=this.animationTime[this.animationIndex]){
                this.animationCurrentTime = 0
                this.animationIndex+=this.animationDirection
                if(this.animationIndex==this.animation.length-1){
                    //this.animationIndex = 0
                    if(this.animationMode=="pingpong"){
                        this.animationDirection = -1
                    }
                    if(this.animationMode=="playonce"){
                        this.animationDirection = 0
                        this.frame=25
                    }
                }
                if(this.animationIndex==0){
                    if(this.animationMode=="pingpong"){
                        this.animationDirection = 1
                    }
                }
                //if(this.animation[this.animationIndex]==25)console.log("ewerwer")
                this.frame = this.animation[this.animationIndex]
                
            }           


    //		If laserwait>0)laserwait-=1
            // Damage to player
            if(developmode == false){
                if(distanceM(myplayer.px+(myplayer.pw/2),myplayer.py+(myplayer.ph/2),this.px+(this.w/2),this.py+(this.h/2)) < tilewidth){
                    myplayer.hp -= 2;
                    // NOTE
                    mynumberfall.push(
                        new numberfall(
                            myplayer.px+(myplayer.pw/2),myplayer.py,2,'red'
                            ) 
                    );
                    //mynumberfall.Add(New numberfall(myplayer.this.px+(myplayer.pw/2),myplayer.this.py,2,Color.Red))
                    if(myplayer.hp < 0 )gamestate = "select";
                }
            }

            
            if(this.px < this.x*this.w)this.px += this.sx
            if(this.px > this.x*this.w)this.px -= this.sx
            if(this.py < this.y*this.h)this.py += this.sy
            if(this.py > this.y*this.h)this.py -= this.sy
            if(this.laserwall()==true)this.changedirection()
            if(distanceM(this.px,this.py,this.x*this.w,this.y*this.h) > 8)return
            //Select state
            if(this.state=="hatched"){
                //Case "hatched"
                this.state="takeoff"
                //ty=3 //move distance
            }
            if(this.state=="takeoff"){
            //Case "takeoff"
                this.takeoff()
            }
            if(this.state=="attack"){
            //Case "attack"
                if(this.canattackplayer() == false){
                    this.state = "roam"
                    this.substate="up"
                    return
                }
                    //Local angle = getangle(this.px,this.py,myplayer.this.px,myplayer.this.py)
                
                this.x = Math.floor(myplayer.px / tilewidth)
                this.y = Math.floor(myplayer.py / tileheight)
            }
            if(this.state=="roam"){
                //Case "roam"								
                
                if(this.canattackplayer())this.state = "attack";

                
                //Select substate
                if(this.substate=="left"){
                //Case "left"
                    this.x-=1						
                    if(mymap.mapfinal[this.x-1][this.y]  != mymap.tileempty){
                        this.substate="right"
                        this.animationFacing="right"
                    }
                    if(this.x<3){
                        this.substate="right"
                        this.animationFacing="right"
                    }
                    // if flying on the ground level)move up 1 tile
                    if(mymap.mapfinal[this.x][this.y+1]  != mymap.tileempty)this.y-=1
                    if(mymap.mapfinal[this.x][this.y-1]  != mymap.tileempty)this.y+=1
                }
                if(this.substate=="right"){
                //Case "right"
                    this.x+=1
                    if(mymap.mapfinal[this.x+1][this.y]  != mymap.tileempty){
                        this.substate="left"
                        this.animationFacing="left"
                    }
                    if(this.x>mapwidth-3){
                        this.substate="left"
                        this.animationFacing="left"
                    }
                    // if flying on the ground level then move up 1 tile						
                    if(mymap.mapfinal[this.x][this.y+1]  != mymap.tileempty)this.y-=1
                    if(mymap.mapfinal[this.x][this.y-1]  != mymap.tileempty)this.y+=1
                }
                if(this.substate=="up"){
                // Case "up"
                    this.y-=1
					//if(this.y<13)this.substate="down"
                    if(mymap.mapfinal[this.x][this.y-2]  != mymap.tileempty) {
                        
                        if(Math.random()<.5){
                            this.substate="left"
                            this.animationFacing="left"
                            }else{
                            this.substate="right"
                            this.animationFacing="right"
                        }							
                    }
                    if(this.y<3){
                        if(Math.random() < .5){
                            this.substate="right"
                            this.animationFacing="right"
                        }else{
                            this.substate="left"
                            this.animationFacing="right"
                        }
                    }
                }
                if(this.substate=="down"){
                    
                    //Case "down"
                    this.y+=1
                    if(mymap.mapfinal[this.x][this.y+2] != mymap.tileempty){
                        if(Math.random() < .5){
                            this.substate="left"		
                            this.animationFacing="left"				
                        }else{
                            this.substate="right"
                            this.animationFacing="right"
                        }
                    }
                }
                // Change direction to up or down if possible
                // sometimes
                                
                this.gorandupordown()
                this.gorandleftorright()
                //change direction sometimes to left or right
                this.landandlayegg()
            }
            if(this.state=="landlayegg"){
            //Case "landlayegg"
                
                this.y+=1
                if(mymap.mapfinal[this.x][this.y+1]  != mymap.tileempty){
                    this.state="layegg"
                }
            }
            if(this.state=="layegg"){

            //Case "layegg"
                if(mymap.mapfinal[this.x][this.y] == mymap.tileempty && mymap.mapfinal[this.x][this.y+1] != mymap.tileegg){
                
                    if(distanceM(myplayer.px,myplayer.py,this.px,this.py) < 100){
                        }else{
                        mymap.mapfinal[this.x][this.y] = 3
                        myegg.push(new egg(this.x,this.y));                        
                        //mymap.updateimage(mymap.mapcanvas)				
                    }
                }else{
                
                }
                this.state="takeoff"
            }
            if(this.state=="roam"){
            //    state="takeoff"
            }
        
            //End Select
        }
        canattackplayer(){
            if(distanceM(this.px,this.py,myplayer.px,myplayer.py) > 200)return false
            var angle = getangle(this.px,this.py,myplayer.px,myplayer.py)
            var clearpath=false;
            var mx = Math.cos(angle)
            var my = Math.sin(angle)
            var monx = this.px
            var mony = this.py
            for(var i=0;i<200;i++){
                monx += mx;
                mony += my;
                if(distanceM(monx,mony,myplayer.px,myplayer.py) < 20)return true
                if(mymap.mapcollide(monx,mony,this.w,this.h) == true)return false;	
                if(this.collidelaserwall(monx,mony,this.w,this.h))return false
            }				
            return true
        }
        collidelaserwall(x,y,w1,h1){
        
            
            for(var i=0;i<mylaserwall.length;i+=1){
                if(rectsoverlap((x-w1)+(randomRangeFloat(-w1,w1)),y-h1,w1*2,
                                h1*2,mylaserwall[i].tx-5,mylaserwall[i].ty,10,mylaserwall[i].by-mylaserwall[i].ty)){
                    return true
                } 
            }
            return false
            
        }
        laserwall(){
            //return false;
            
            for(var i=0;i<mylaserwall.length;i+=1){
                if(rectsoverlap(    (this.px-this.w)+(randomRangeFloat(-this.w,this.w)),
                                    this.py-this.h,this.w*2,this.h*2,
                                    mylaserwall[i].tx-5,mylaserwall[i].ty,10,mylaserwall[i].by-mylaserwall[i].ty)){
                    return true
                } 
        }
            return false
            
        }
        changedirection(){
            this.state = "roam"
            if(this.substate == "left"){
                this.substate="right" 
                this.x += 2;		
            }else{ 
                this.substate="left"
                this.x -= 2;
            }
        }
        landandlayegg(){

            // Sometimes land and lay egg
            if(Math.random() < (egglayingfreq/10)){
                // Debug - So monster will not lay egg in player
                
                var exitloop=false
                var y1=this.y
                var egghere=false
                while(exitloop == false){
                    if(mymap.mapfinal[this.x][y1] == 3){
                        return
                    }
                    if(mymap.mapladder[this.x][y1] == 1){
                        return 
                    }
                    if(mymap.mapfinal[this.x][y1]  != mymap.tileempty)exitloop = true
                    y1+=1;
                }
                var cnt=0;
                for(var i=0;i<myflyingmonster.length;i++){
                    cnt+=1
                }
                //if more then max monsters no lay egg
                if(cnt<maxflyingmonsters){		
                    this.state="landlayegg";

                }
            }	
        }
        gorandleftorright(){
            if(this.substate =="up" || this.substate =="down"){
                if(Math.random() < 0.1){
                    var exitloop=false
                    var x1=this.x
                    var cnt=0
                    while(exitloop == false){
                        x1-=1
                        cnt+=1
                        if(mymap.mapfinal[x1][this.y] != mymap.tileempty || x1<3){
                            exitloop = true;
                        }
                    }				
                    if(cnt>8){
                        this.substate = "left"
                        this.animationFacing = this.substate
                        this.setSideFlyAnimation()
                    }
                }
                if(Math.random() < 0.1){
                    var exitloop=false
                    var x1=this.x
                    var cnt=0
                    while(exitloop == false){
                        x1+=1
                        cnt+=1
                        if(mymap.mapfinal[x1][this.y] != mymap.tileempty || x1>mapwidth-3){
                            exitloop = true
                        }
                    }			
                    if(cnt>8){
                        this.substate = "right"
                        this.animationFacing = this.substate
                        this.setSideFlyAnimation()
                    }	

                }
            }			
        }
        gorandupordown(){
            if(this.substate == "left" || this.substate == "right"){
                if(Math.random() < .1){
                    var exitloop=false
                    var y1=this.y
                    var cnt=0
                    while(exitloop==false){
                        y1-=1
                        cnt+=1
                        if(mymap.mapfinal[this.x][y1] != mymap.tileempty){
                            exitloop = true
                        }
                        if(y1<3)exitloop = true
                    }			
                    if(cnt>8){
                        this.substate="up"
                        this.animationFacing = this.substate
                        this.setFrontFlyAnimation()
                    }					
                }
                if(Math.random() < .13 && this.substate!="up"){					
                    var exitloop=false
                    var y1=this.y
                    var cnt=0
                    while(exitloop==false){
                        y1+=1
                        cnt+=1
                        if(mymap.mapfinal[this.x][y1]  != mymap.tileempty){
                            exitloop = true
                        }
                    }
                    if(cnt>8){
                        this.substate="down"
                        this.animationFacing = this.substate
                        this.setFrontFlyAnimation()
                    }
                }
            }	
        }
        takeoff(){
            this.y-=1
            if(mymap.mapfinal[this.x][this.y-1]  != mymap.tileempty){
                this.state="roam"
                if(randomRangeFloat(0,1) < 0.5){ 
                    this.substate="left"
                    this.animationFacing = this.substate
                    this.setFrontFlyAnimation()

                }else{
                    this.substate="right"
                    this.animationFacing = this.substate
                    this.setFrontFlyAnimation()

                }
            }
        }
        draw(){
            var x1=(screenwidth-48)/mapwidth*this.x
            var y1=(screenheight-48)/mapheight*this.y
            //canvas.Color = Color.White
            //SetColor 255,255,255
            ctx.fillStyle = 'white'
            ctx.fillRect(x1,y1,3+2,3+2)
            ctx.fillStyle = 'red'
            ctx.fillRect(x1+1,y1+1,3,3)
            //canvas.DrawRect(x1,y1,3+2,3+2)
            //canvas.Color = Color.Red
            //SetColor 255,0,0		
            //canvas.DrawRect(x1+1,y1+1,3,3)

        }
   
    }



    //
    // Items that move towards the player and into his inventory
    // by mining,
    //
    class item{
        constructor(x,y,kind){
            this.px,this.py;
            this.w,this.h;
            this.deleteme;
            this.angle;
            this.mx,this.my;
            this.speed;
            this.kind; //coal,metal,gold,rock	
            this.removetime=2000;
            this.time;

            this.inRange = true
            this.inRangeCnt = 0
            this.inRangeCntMax = 30

            this.px = x;
            this.py = y;
            this.kind = kind;
            this.mx = randomRangeFloat(-2,2);
            this.my = 0;
            this.w = 3;
            this.h = 3;

            if(mymap.mapcollide(this.px,this.py,this.w,this.h) == true){ 						
                    this.deleteme = true
            }

        }
        update(){
            this.inRangeCnt+=1
            if(this.inRangeCnt>this.inRangeCntMax){
                this.inRangeCnt = 0;
                if(distanceM(myplayer.px,myplayer.py,this.px,this.py)>drawDistance){
                    this.inRange=false
                }else{
                    this.inRange=true
                }
            }            
            // if to long in game then remove
            this.time+=1;
            if(this.time>this.removetime)this.deleteme=true;
            // get player center position
            var pcx=myplayer.px + (myplayer.pw/2);
            var pcy=myplayer.py + (myplayer.ph/2);
            //if distance closest then add to player inventory		
            if(distanceM(pcx,pcy,this.px,this.py) < 10){
                // code to add to player inventory here...
                this.addtoplayerinventory();	
                this.deleteme = true;
            }

            // gravity
            if(mymap.mapcollide(this.px,this.py+Math.ceil(this.my)+2,this.w,this.h) == false){ 			
                if(this.my<3)this.my+=.1;
            }else{
                this.my=0;
            }

            // if in range then move to player
            if(distanceM(pcx,pcy,this.px,this.py) < 150){ 			
                this.angle = getangle(this.px,this.py,pcx,pcy);
                this.mx = Math.cos(this.angle);
                this.my = Math.sin(this.angle);			
            }else{
                if(this.mx > 0)this.mx-=.01;
                if(this.mx < 0)this.mx+=.01;
                if(this.mx<0.1 && this.mx>0)this.mx=0;
                if(this.mx>-0.1 && this.mx<0)this.mx=0;
                            
            }

            // floor collision
            if(mymap.mapcollide(this.px,this.py+1,this.w,this.h) == true){ 						
                    this.my=-1;
            }

            // ceiling collision
            if(mymap.mapcollide(this.px,this.py-1,this.w,this.h) == true){ 						
                    this.my=1;
            }
            // left side collision
            if(mymap.mapcollide(this.px-1,this.py,this.w,this.h) == true){ 						
                    this.mx=1;
            }
            // right side collision
            if(mymap.mapcollide(this.px+1,this.py,this.w,this.h) == true){ 						
                    this.mx=-1;
            }

            // move the item
            this.px += this.mx;
            this.py += this.my;		
        }
        addtoplayerinventory(){
            for(var i=0;i<myplayer.playeritemnames.length;i+=1){
                if(this.kind == myplayer.playeritemnames[i]){
                    
                    myplayer.playeritem[i][1] += 1;
                    return;
                }
            }
        }
    }

    //fragmentation things
    class frag{
        constructor(x,y,owner){
            this.px,this.py; //pixel x and y
            this.owner;
            this.angle;
            this.w,this.h;
            this.deleteme=false;
            this.countdown;
            this.mx;
            this.my;
            this.fragspeed;

            this.owner = owner;
            this.px = x;
            this.py = y;
            this.w = 3;
            this.h = 3;
            this.fragspeed = randomRange(4,7);
            this.countdown = 100+randomRange(0,300);
            this.angle = randomRangeFloat(0,Math.PI*2);
            this.mx = Math.cos(this.angle);
            this.my = Math.sin(this.angle);

        }
        update(){		
            for(var ps=0;ps<this.fragspeed;ps+=1){  
                this.countdown-=1;
                if(this.countdown < 0){
                    
                    this.deleteme = true; 
                    return;
                }
                
                //Collision with mineable tiles
                if(mymap.mapmineablecollide(this.px-4,this.py-4,this.w+8,this.h+8,true,"frag")==true){
                    //this.deleteme = true;
                }
                
                //Collision with the slime
                if(mygrowslime.slimecollide(this.px-2,this.py-2,this.w+4,this.h+4,true)==true){
                    this.deleteme = true;
                }
                
                
                //bouncy vertical
                if(mymap.mapcollide(this.px,this.py+2,1,this.h)==true){ 			
                    this.my = -this.my*.8;//+Rnd(-.1,.1)
                    var cnt=0;
                    while(mymap.mapcollide(this.px,this.py+2,1,this.h)==true){
                        this.py+=this.my;
                        cnt+=1;
                        if(cnt>100)break;
                    }
                    this.mx*=.8;
                    this.my*=.8;
                    if(this.my<0 && this.my>-0.2)this.my=-0.2;
                    if(this.my>0 && this.my<.2)this.my=.2;
                    if(this.mx<0 && this.mx>-0.2)this.mx=-0.2;
                    if(this.mx>0 && this.mx<.2)this.mx=.2;
                    
                }
                //bounc ceiling
                if(mymap.mapcollide(this.px,this.py-2,1,this.h)==true){		
                    //slimed=slimecollide(px,py+2,1,h)
                    //If slimed = true Then return
                    this.my = -this.my*.8
                    var cnt=0;
                    while(mymap.mapcollide(this.px,this.py-2,1,this.h)==true){
                        this.py+=this.my;
                        cnt+=1;
                        if(cnt>100)break;
                    }
                
                    this.mx*=.8;
                    this.my*=.8;
                
                    if(this.my<0 && this.my>-0.2)this.my=-0.2;
                    if(this.my>0 && this.my<.2)this.my=.2;
                    if(this.mx<0 && this.mx>-0.2)this.mx=-0.2;
                    if(this.mx>0 && this.mx<.2)this.mx=.2;
                
                }		
                //bounce horizontally
                if(mymap.mapcollide(this.px-this.w,this.py,this.w*2,1)==true){ 			
                    this.mx = -this.mx*.8//+Rnd(-.1,.1)
                    var cnt=0;
                    while(mymap.mapcollide(this.px-this.w,this.py,this.w*2,1)==true){
                        this.px+=this.mx;	
                        cnt+=1;
                        if(cnt>100)break;			
                    }
                    this.mx*=.8;
                    this.my*=.8;
                    if(this.my<0 && this.my>-0.2)this.my=-0.2
                    if(this.my>0 && this.my<.2)this.my=.2
                    if(this.mx<0 && this.mx>-0.2)this.mx=-0.2
                    if(this.mx>0 && this.mx<.2)this.mx=.2
                    
                }
                
                this.px += this.mx;
                this.py += this.my;
                this.my+=.005;
                



                
                // frag collision with walking monsters
                for(var i=0;i<mywalkingmonster.length;i+=1){
                    if(distanceM(mywalkingmonster[i].px,mywalkingmonster[i].py,this.px,this.py) < 10){
                        mywalkingmonster[i].hp -= 5
                        //mynumberfall.Add(New numberfall(i.px+(i.w/2),i.py,5,Color.Red))
                        mynumberfall.push(
                            new numberfall(
                                mywalkingmonster[i].px+(mywalkingmonster[i].w/2),mywalkingmonster[i].py,5,'red'
                                ) 
                        );

                        if(mywalkingmonster[i].hp<=0){
                            mywalkingmonster[i].deleteme = true
                            //myitem.Add(New item(i.px,i.py,"Monster Tail"))
                              myitem.push(
                                new item(
                                this.px,this.py,"Monster Tail"    
                                ) 
                            );
                        }
                        this.deleteme = true
                        return;
                    }
                }
                
                
                // frag collision with flying monsters
                for(var i=0;i<myflyingmonster.length;i++){
                    if(distanceM(myflyingmonster[i].px,myflyingmonster[i].py,this.px,this.py) < 10){
                        myflyingmonster[i].hp -= 5
                        mynumberfall.push(
                            new numberfall(
                                myflyingmonster[i].px+(myflyingmonster[i].w/2),myflyingmonster[i].py,5,'red'
                                ) 
                        );

                        //mynumberfall.Add(New numberfall(i.px+(i.w/2),i.py,5,Color.Red))
                        if(myflyingmonster[i].hp<=0){
                            myflyingmonster[i].deleteme = true
                            myitem.push(
                                new item(
                                this.px,this.py,"Monster Tooth"    
                                ) 
                            );
                            //myitem.Add(New item(i.px,i.py,"Monster Tooth"))
                        }
                        this.deleteme = true;
                        return;
                    }
                }	
                
                // frag collision with the eggs
                if(this.eggcollide(this.px-1,this.py-1,this.w+2,this.h+2)==true){
                    this.deleteme = true
                    //myitem.Add(New item(px,py,"Egg Shell"))
                    return;
                }
            }
        }	

    
        eggcollide(x,y,w,h){
            var lefttopx		=Math.floor(((x)/tilewidth));
            var lefttopy		=Math.floor(((y)/tileheight));
            var righttopx		=Math.floor(((x+w)/tilewidth));
            var righttopy		=Math.floor(((y)/tileheight));
            var leftbottomx 	=Math.floor(((x)/tilewidth));
            var leftbottomy 	=Math.floor(((y+h)/tileheight));
            var rightbottomx	=Math.floor(((x+w)/tilewidth));												
            var rightbottomy	=Math.floor(((y+h)/tileheight));
            var x2=-1,y2=-1;
            if(mymap.mapfinal[lefttopx][lefttopy] == mymap.tileegg){
                x2=lefttopx;
                y2=lefttopy;
            }
            if(mymap.mapfinal[righttopx][righttopy] == mymap.tileegg){
                x2=righttopx;
                y2=righttopy;
            }
            if(mymap.mapfinal[leftbottomx][leftbottomy] == mymap.tileegg){
                x2=leftbottomx;
                y2=leftbottomy;
            }
            if(mymap.mapfinal[rightbottomx][rightbottomy] == mymap.tileegg){
                x2=rightbottomx;
                y2=rightbottomy;
            }
            if( x2 != -1 ) {			
                // destroy egg
                if(randomRange(0,2)<1){
                    mymap.mapfinal[x2][y2] = mymap.tileempty;
                    // destroy egg in myegg
                    for(var i=0;i<myegg.length;i+=1){
                        if(myegg[i].x==x2 && myegg[i].y==y2){
                            if(myegg[i].frame>1){
                                myegg[i].state="animate"
                                myegg[i].frame=5                            
                            }else{
                                myegg[i].deleteme = true
                            }
                            return true
                        }
                    }
                    //myitem.Add(New item(x2*tilewidth,y2*tileheight,"gold"))
                    //mymap.updateimage(mymap.mapcanvas)
                }
                return true;
            }
            return false;
        }    			

    }



    class grenade{
        
        constructor(x,y,facing){
            
            this.px,this.py; //pixel x and y
            this.slimed=false;
            this.angle;
            this.w,this.h;
            this.deleteme;
            this.countdown;
            this.mx;
            this.my;
            this.px = x;
            this.py = y;
            this.w = 6;
            this.h = 6;
            this.countdown = 500;
            if(facing=="left"){
                this.angle=Math.PI+.3;
            }
            if(facing=="right"){
                this.angle=0-.3;
            }
            if(facing=="up"){
                this.angle=Math.PI*1.55 + randomRangeFloat(-.2,.2);
            }
            if(facing=="down"){
                this.angle = Math.PI/2 + randomRangeFloat(-.2,.2);
            }
            if(facing=="leftup"){
            //if(Controller.Left==true && Controller.Up==true){
                this.angle = -Math.PI/1.2
                
            }else
                //if(Controller.Right==true && Controller.Up==true){
                if(facing=="rightup"){
                this.angle = -Math.PI/4
            }else

                //if(Controller.Right==true && Controller.Down==true){
                if(facing=="rightdown"){
                this.angle = Math.PI/4
            }else

               // if(Controller.Left==true && Controller.Down==true){
                if(facing=="leftdown"){
                this.angle = Math.PI-Math.PI/4

            }            
            //this.angle = angle;
            // Set the movement speed of the grenade. Add a bit of randomization
            this.mx = Math.cos(this.angle)+randomRangeFloat(-0.15,0.15)
            this.my = Math.sin(this.angle)+randomRangeFloat(-0.15,0.15)
            // Make sure the grenade does not start inside the start location
            // but a bit outside of the tile dimension
            this.px+=Math.cos(this.angle)*(tilewidth/3)
            this.py+=Math.sin(this.angle)*(tileheight/3)
        }
        update(){	
            
            for(var bulletspeed=0;bulletspeed<4;bulletspeed+=1){
                
                //Life of frags	
                this.countdown-=1;
                if(this.countdown < 0){ 
                    
                    this.deleteme = true;
                    var numfrags=randomRange(6,20);
                    for(var i=0;i<numfrags;i+=1){

                        // NOTE :
                        //myfrag.AddLast(New frag(px,py,"player"))
                        
                        myfrag.push(
                            
                            new frag(
                                this.px,this.py,"player"
                            )
                        );
                    }
                    return;
                }
                                
                if(this.slimed==false){ 
                    

                    if(this.slimecollide(this.px-this.w,this.py-this.h,this.w*2.5,this.h*2.5)){
                        this.slimed = true; 
                        continue;
                    }
                    //bounce ceiling
                    
                    if(this.mapcollide(this.px,this.py-2,1,this.h)==true){ 			
                        //slimed=slimecollide(px,py+2,1,h)
                        //If slimed = True Then Return
                        this.my = -this.my*.8;
                        var cnt=0;
                        while(this.mapcollide(this.px,this.py-2,1,this.h)==true){
                            this.py+=this.my;
                            cnt+=1;
                            if(cnt>100)break;
                        }
                    
                        this.mx*=.8;
                        this.my*=.8;
                    
                        if(this.my<0 && this.my>-0.2)this.my=-0.2;
                        if(this.my>0 && this.my<.2)this.my=.2;
                        if(this.mx<0 && this.mx>-0.2)this.mx=-0.2;
                        if(this.mx>0 && this.mx<.2)this.mx=.2;
                    
                    }

    
                    //bouncy vertical
                    if(this.mapcollide(this.px,this.py+2,1,this.h)==true){ 			
                        ////slimed=slimecollide(px,py+2,1,h)
                        ////If slimed = True Then Return
                        this.my = -this.my*.8;//'-.1,.1)
                        var cnt=0;
                        while(this.mapcollide(this.px,this.py+2,1,this.h)==true){
                            this.py+=this.my;
                            cnt+=1;
                            if(cnt>100)break;
                        }
                        
                        this.mx*=.8;
                        this.my*=.8;
                        
                        if(this.my<0 && this.my>-0.2)this.my=-0.2;
                        if(this.my>0 && this.my<.2)this.my=.2;
                        if(this.mx<0 && this.mx>-0.2)this.mx=-0.2;
                        if(this.mx>0 & this.mx<.2)this.mx=.2;
                        
                    }
                    //'bounce horizontally
                    if(this.mapcollide(this.px-this.w,this.py,this.w*2,1)==true){ 			
                        //'slimed=mapcollide(px-w,py,w*2,1)
                        //'If slimed Then Return
                        this.mx = -this.mx*.8;//'+Rnd(-.1,.1)
                        var cnt=0;
                        while(this.mapcollide(this.px-this.w,this.py,this.w*2,1)==true){
                            this.px+=this.mx;
                            cnt+=1;
                            if(cnt>100)break;			
                        }
                        this.mx*=.8;
                        this.my*=.8;			
                        if(this.my<0 && this.my>-0.2)this.my=-0.2;
                        if(this.my>0 && this.my<.2)this.my=.2;
                        if(this.mx<0 && this.mx>-0.2)this.mx=-0.2;
                        if(this.mx>0 && this.mx<.2)this.mx=.2;
                        
                    }
            
                    //' update the frag location
                    this.px += this.mx;
                    this.py += this.my;
                    this.my+=.005;
                    
                }
            
            }
        }
        mapcollide(x,y,w,h){
            
            var mmw=mymap.mmw;
            var mmh=mymap.mmh;
            var lefttopx		=Math.floor(((x)/tilewidth));
            var lefttopy		=Math.floor(((y)/tileheight));
            var righttopx		=Math.floor(((x+w)/tilewidth));
            var righttopy		=Math.floor(((y)/tileheight));
            var leftbottomx 	=Math.floor(((x)/tilewidth));
            var leftbottomy 	=Math.floor(((y+h)/tileheight));
            var rightbottomx	=Math.floor(((x+w)/tilewidth));												
            var rightbottomy	=Math.floor(((y+h)/tileheight));
            if(lefttopx < 0 || lefttopx >= mmw)return true;
            if(lefttopy < 0 || lefttopy >= mmh)return true;
            if(righttopx < 0 || righttopx >= mmw)return true;
            if(righttopy < 0 || righttopy >= mmh)return true;
            if(leftbottomx < 0 || leftbottomx >= mmw)return true;
            if(leftbottomy < 0 || leftbottomy >= mmh)return true;
            if(rightbottomx < 0 || rightbottomx >= mmw)return true;
            if(rightbottomy < 0 || rightbottomy >= mmh)return true;
            


   
           
            if(mymap.mapfinal[lefttopx][lefttopy] != mymap.tileempty && 
                mymap.mapfinal[lefttopx][lefttopy] != mymap.tileegg )return true;
            if(mymap.mapfinal[righttopx][righttopy] != mymap.tileempty && 
                mymap.mapfinal[righttopx][righttopy] != mymap.tileegg)return true;
            if(mymap.mapfinal[leftbottomx][leftbottomy] != mymap.tileempty &&
                mymap.mapfinal[leftbottomx][leftbottomy] != mymap.tileegg )return true;
            if(mymap.mapfinal[rightbottomx][rightbottomy] != mymap.tileempty &&
                mymap.mapfinal[rightbottomx][rightbottomy] != mymap.tileegg )return true;						

            //If mygrowslime.map[lefttopx*2,lefttopy*2] = mymap.tileslime Then Return True
            //If mygrowslime.map[righttopx*2,righttopy*2] = mymap.tileslime Then Return True
            //If mygrowslime.map[leftbottomx*2,leftbottomy*2] = mymap.tileslime Then Return True
            //If mygrowslime.map[rightbottomx*2,rightbottomy*2] = mymap.tileslime Then Return True						

            return false;
        }	
        slimecollide(x,y,w,h){

            var mmw=mymap.mmw;
            var mmh=mymap.mmh;
            var lefttopx		=((x)/tilewidth);
            var lefttopy		=((y)/tileheight);
            var righttopx		=((x+w)/tilewidth);
            var righttopy		=((y)/tileheight);
            var leftbottomx 	=((x)/tilewidth);
            var leftbottomy 	=((y+h)/tileheight);
            var rightbottomx	=((x+w)/tilewidth);												
            var rightbottomy	=((y+h)/tileheight);

            // '		If lefttopx < 0 Or lefttopx >= mmw Then Return True
            //'		If lefttopy < 0 Or lefttopy >= mmh Then Return True
            //'		If righttopx < 0 Or righttopx >= mmw Then Return True
            //'		If righttopy < 0 Or righttopy >= mmh Then Return True
            //'		If leftbottomx < 0 Or leftbottomx >= mmw Then Return True
            //'		If leftbottomy < 0 Or leftbottomy >= mmh Then Return True
            //'		If rightbottomx < 0 Or rightbottomx >= mmw Then Return True
            //'		If rightbottomy < 0 Or rightbottomy >= mmh Then Return True
            //'	
            
            if(mygrowslime.map[Math.floor(lefttopx*2)][Math.floor(lefttopy*2)] == mymap.tileslime)return true
            if(mygrowslime.map[Math.floor(righttopx*2)][Math.floor(righttopy*2)] == mymap.tileslime)return true
            if(mygrowslime.map[Math.floor(leftbottomx*2)][Math.floor(leftbottomy*2)] == mymap.tileslime)return true
            if(mygrowslime.map[Math.floor(rightbottomx*2)][Math.floor(rightbottomy*2)] == mymap.tileslime)return true						
        
            return false;
        }	
        
        
		
    }



    class bullet{
        constructor(x,y,angle,owner,kind){
            this.px,this.py;
            this.mx,this.my;
            this.angle;
            this.w,this.h;
            this.deleteme;
            this.countdown;
            this.owner;	

            this.owner = owner;
            this.px = x;
            this.py = y;		
         
            this.w = 2;
            this.h = 2;
            this.mx = 1;
            this.my = 1;
            this.deleteme = false;
            if(this.kind="shotgun"){
                this.w = 2;
                this.h = 2;
                this.mx = randomRangeFloat(.9,1);
                this.my = randomRangeFloat(.9,1);
            }
            this.countdown = 400+randomRange(0,100);
            this.angle = angle;
            	
        }
        update(){
            for(var bulletspeed=0;bulletspeed<5;bulletspeed++){
                this.countdown-=1
                if(this.countdown < 0){
                    this.deleteme = true;
                    return;
                }
                
                if(mymap.mapcollide2(this.px,this.py,this.w,this.h)==true)this.deleteme = true;
            
                
                // Collision with a mineable tile
                if(mymap.mapmineablecollide(this.px-2,this.py-2,this.w+4,this.h+4,true,"gun")==true){
                    this.deleteme = true;
                    return;
                }		
                
                
                // Collision with the slime
                if(mygrowslime.slimecollide(this.px-2,this.py-2,this.w+4,this.h+4,true)==true){
                    this.deleteme = true;
                    return;
                    //'Print Millisecs()
                }		
                
                
                // Collision with bullet and walking monster
                for(var i=0;i<mywalkingmonster.length;i++){
                    if(mywalkingmonster[i].inRange==false)continue
                    if(distanceM(this.px,this.py,mywalkingmonster[i].px,mywalkingmonster[i].py) < tilewidth){ 
                        mywalkingmonster[i].hp -= 1;
                        mynumberfall.push(
                            new numberfall(
                                mywalkingmonster[i].px+(mywalkingmonster[i].w/2),mywalkingmonster[i].py,5,'red'
                                ) 
                        );

                        //'mynumberfall.Add(New numberfall(i.px+(i.w/2),i.py,1,Color.Red))

                        this.deleteme = true;		;		
                        if(mywalkingmonster[i].hp <= 0){
                            mywalkingmonster[i].deleteme = true;					
                            //myitem.Add(New item(this.px,this.py,"Monster Tail"))
                            myitem.push(
                                new item(
                                    this.px,this.py,"Monster Tail"    
                                ) 
                                   
                                 
                            );
                            return;
                        }
                        return;
                    }
                }
                
                
                // Collision with bullet and flying monster
                for(var i=0;i<myflyingmonster.length;i++){
                    if(myflyingmonster[i].inRange==false)continue
                    if(distanceM(this.px,this.py,myflyingmonster[i].px,myflyingmonster[i].py) < tilewidth){
                        myflyingmonster[i].hp -= 1
                        mynumberfall.push(
                            new numberfall(
                                myflyingmonster[i].px+(myflyingmonster[i].w/2),myflyingmonster[i].py,5,'red'
                                ) 
                        );

                        //mynumberfall.Add(New numberfall(myflyingmonster[i].px+(myflyingmonster[i].w/2),myflyingmonster[i].py,1,'red'))
                        //mynumberfall.push(
                        //    new numberfall(
                        //    myflyingmonster[i].px+(myflyingmonster[i].w/2),myflyingmonster[i].py,1,'red' 
                        //    ) 
                        //);

                        this.deleteme = true;			
                        if(myflyingmonster[i].hp <= 0){
                            myflyingmonster[i].deleteme = true;					
                            //myitem.Add(New item(px,py,"Monster Tooth"))
                            myitem.push(
                                new item(
                                this.px,this.py,"Monster Tooth"    
                                ) 
                            );
                            return;
                        }
                        return;
                    }
                }
                
                // Collision with bullet and egg
                if(this.eggcollide(this.px,this.py,this.w,this.h)){ 						
                    this.deleteme = true;
                    //myitem.Add(New item(px,py,"Egg Shell"))
                    
                    myitem.push(
                        new item(
                        this.px,this.py,"Egg Shell"    
                        ) 
                    );
                    
                    return;
                }
                
                this.px += Math.cos(this.angle)*this.mx;
                this.py += Math.sin(this.angle)*this.my;
                
            }
        }
        //
        // NOTE : Eggs are randomly removed here if hit.
        //
        eggcollide(x,y,w,h){
            var lefttopx		=Math.floor(((x)/tilewidth));
            var lefttopy		=Math.floor(((y)/tileheight));
            var righttopx		=Math.floor(((x+w)/tilewidth));
            var righttopy		=Math.floor(((y)/tileheight));
            var leftbottomx	    =Math.floor(((x)/tilewidth));
            var leftbottomy	    =Math.floor(((y+h)/tileheight));
            var rightbottomx	=Math.floor(((x+w)/tilewidth));											
            var rightbottomy	=Math.floor(((y+h)/tileheight));
            
            var x2=-1,y2=-1;
            if(mymap.mapfinal[lefttopx][lefttopy] == mymap.tileegg){
                x2=lefttopx;
                y2=lefttopy;
            }
            if(mymap.mapfinal[righttopx][righttopy] == mymap.tileegg){
                x2=righttopx;
                y2=righttopy;
            }
            if(mymap.mapfinal[leftbottomx][leftbottomy] == mymap.tileegg){
                x2=leftbottomx;
                y2=leftbottomy;
            }
            if(mymap.mapfinal[rightbottomx][rightbottomy] == mymap.tileegg){
                x2=rightbottomx;
                y2=rightbottomy;
            }
            if(x2!=-1){			
                if(randomRange(0,7)<1){ 
                    mymap.mapfinal[x2][y2] = mymap.tileempty;
                    //mymap.updateimage(mymap.mapcanvas)
                  // destroy egg in myegg
                    for(var i=0;i<myegg.length;i+=1){
                        if(myegg[i].x==x2 && myegg[i].y==y2){
                            if(myegg[i].frame>1){
                                myegg[i].state="animate"
                                myegg[i].frame=5                            
                            }else{
                                myegg[i].deleteme = true
                            }
                            return true
                        }
                    }
                }
                return true;
            }
            return false;
        }			
    }


    //
    // This is the code for the people in the town.
    //
    class townperson{
        constructor(x,y){
            this.px,this.py; //'pixel position (0-width)
            this.sx,this.sy; //'movement speed
            this.x,this.y;//'tile x and y position
            this.w,this.h;
            this.hp; //'hitpoints
            this.hpmax;
            this.deleteme;
            this.state;
            this.substate;
            this.jx;
            this.jy;
            this.oldpy; //'old py coordinate


            this.inRange = true
            this.inRangeCnt = 0
            this.inRangeCntMax = 30
            this.x = x;
            this.y = y;
            this.w = tilewidth;
            this.h = tileheight;
            this.px = this.x*this.w;
            this.py = this.y*this.h;
            this.hp = randomRange(10,30);
            this.hpmax = this.hp;
            //'set the movement speed
            this.sx = Math.random();
            
            //'		sy = sx
            this.state="roam";
            if(randomRange(0,10)<2){
                this.substate="left";
             }else{ 
                this.substate="stand";
             }
        }
        update(){		
            this.inRangeCnt+=1
            if(this.inRangeCnt>this.inRangeCntMax){
                this.inRangeCnt = 0;
                if(distanceM(myplayer.px,myplayer.py,this.px,this.py)>drawDistance){
                    this.inRange=false
                }else{
                    this.inRange=true
                }
            }
            //'		If laserwait>0 Then laserwait-=1
            
            if(this.px < this.x*this.w){
                this.px += this.sx;
            }
            if(this.px > this.x*this.w){
                this.px -= this.sx;
            }
            if(distanceM(this.px,this.py,this.x*this.w,this.y*this.h) > 8)return;
                    
            if(this.state=="roam"){
                if(this.substate=="left"){
                    
                    ///Case "roam"												
                    //    Select substate
                    //        Case "left"
                    if(this.x<3){
                        this.substate="right";
                        return;
                    }
                    this.x-=1;
                    //'If Rnd(50) < 1 And mymap.mapfinal[x-1,y] = mymap.tileempty And mymap.mapfinal[x-1,y+1] <> mymap.tileempty Then substate="right"						
                    //'If Rnd(50) < 1 And cannotgohere(x+1,y) = False And cannotgohere(x+1,y+1)=True Then substate="right" 
                    if(this.cannotgohere(this.x-1,this.y) == true)this.substate = "right"
                    if(this.cannotgohere(this.x-1,this.y+1) == false)this.substate = "right"
                    //'If mymap.mapfinal[x-1,y]  <> mymap.tileempty Then substate="right"
                    //'If mymap.mapfinal[x-1,y+1] = mymap.tileempty Then substate="right"
                }
                 if(this.substate=="right"){           
                        //Case "right"						
                            if(this.x>mapwidth-3){
                                this.substate="left";
                                return;
                            }
                            this.x+=1;
                            //'If Rnd(50) < 1 And cannotgohere(x-1,y) =  False And cannotgohere(x-1,y+1)=True) substate="left"
                            if(this.cannotgohere(this.x+1,this.y) == true)this.substate="left"
                            if(this.cannotgohere(this.x+1,this.y+1) == false)this.substate="left"
                            //'If Rnd(50) < 1 And mymap.mapfinal[x+1,y] = mymap.tileempty And mymap.mapfinal[x+1,y+1] <> mymap.tileempty Then substate="left"						
                            //'If mymap.mapfinal[x+1,y]  <> mymap.tileempty Then substate="left"
                            //'If mymap.mapfinal[x+1,y+1] = mymap.tileempty Then substate="left"
                 }        
                //End Select
                this.randaction();
            }
        }
        randaction(){
            if(this.substate == "left" && randomRange(0,600)<2){
                this.changedirection();
                return;
            }
            if(this.substate == "right" && randomRange(0,600)<2){
                this.changedirection();
                return;
            }
            if(this.substate == "stand" && randomRange(0,600)<2){ 
                if(randomRange(2) < 1){
                    this.substate = "left";
                 }else{
                    this.substate="right";
                 }
                return;
            }
            if(randomRange(100) < 2){
                this.substate = "stand";
                return;
            }
        }
        //Check if tile on map is blocked
        cannotgohere(x,y){
            if(mymap.mapfinal[x][y] == mymap.tilesolid)return true;
            if(mymap.mapfinal[x][y] == mymap.tilemineable)return true;
            if(mymap.mapfinal[x][y] == mymap.tileturret)return true;
            return false;
        }
        changedirection(){
            this.state = "roam";
            if(this.substate == "left"){ 
                this.substate="right"; 
                this.x += 2;		
            }else{ 
                this.substate="left";
                this.x -= 2;
            }
        }
        // NOTE : MiniMap?
        draw(){
                var x1=screenwidth/mapwidth*this/x;
                var y1=screenheight/mapheight*this.y;
                ctx.fillStyle = 'white';
                ctx.fillRect(x1,y1,3+2,3+2);
                ctx.fillStyle = 'red';
                ctx.fillRect(x1+1,y1+1,3,3);
                //canvas.Color = Color.White
                //SetColor 255,255,255
                //canvas.DrawRect(x1,y1,3+2,3+2)
                //canvas.Color = Color.Red
                //SetColor 255,0,0		
                //canvas.DrawRect(x1+1,y1+1,3,3)
        
        }
    }


    // our player inc (drawmap game routine)
    class player{
        constructor(x,y){
            // Variable initialisation
            this.x=x;
            this.y=y;
            this.hp=100;
            this.hpmax=100;
            this.playeritemnames=["Gold","Coal","Metal","Rock","Shotgun Round","Grenade","Sticky Grenade","Monster Tail","Monster Tooth","Egg Shell"];
            this.playeritem = [];
            this.regularmode=true;
            this.jump=false;
            this.incy=0;
            this.movespeed;
            this.px;
            this.py;
            this.pmx,this.pmy;
            this.ptx,this.pty; // tile x and y position
            this.optx,this.opty // old tile x and y position
            this.mox=0,this.moy=0;
            this.pw,this.ph;	
            this.mcx,this.mcy,this.mpx,this.mpy; // scroll coordinates
            this.maptileswidth,this.maptilesheight;
            this.tw=tilewidth;
            this.th=tileheight;
            this.facing="right";
            this.facingVert="";
            this.gtkd=false; //grenade thrown key down
            this.sfkd=false; //shogun fire key down
            this.minedelay;
            //
            // Set variables and further initialisation
            this.movespeed = 1;
            this.px = tilewidth*mapwidth/2-64;
            this.py = tileheight*14;
            
            this.pw = tilewidth;
            this.ph = tileheight;
            this.maptileswidth = Math.floor(screenwidth / this.tw);
            this.maptilesheight = Math.floor(screenheight / this.th);

            this.mcx=Math.floor(this.px/tilewidth)-Math.floor(this.maptileswidth/2);
            
            this.mcy=Math.floor(this.py/tilewidth)-Math.floor(this.maptilesheight/2);
            
            this.playeritem = create2DArray(this.playeritemnames.length,2);
            //this.createrandominventory();

            this.currentAnimation = "standingAnimation" //walkingAnimation // aimUup//aimRightup..aimRight//aimRightDown//aimDown

            this.frame = 60
            this.animationMode = "loop" 
            this.animation = [60,61,62,63,64]
            this.animationTime = [10,10,10,10,10]
            this.animationIndex = 0
            this.animationDirection = 1
            this.animationCurrentTime = 0
            this.setStandingAnimation()
           
        }
        setAimUpAnimation(){
            this.currentAnimation = "aimUp"
            this.frame = 69
            this.animationMode = "loop" 
            this.animation = [69]
            this.animationTime = [10]
            this.animationIndex = 0
            this.animationDirection = 1
            this.animationCurrentTime = 0
        }          

        setAimRightUpAnimation(){
            this.currentAnimation = "aimRightUp"
            this.frame = 68
            this.animationMode = "loop" 
            this.animation = [68]
            this.animationTime = [10]
            this.animationIndex = 0
            this.animationDirection = 1
            this.animationCurrentTime = 0
        }          

        setAimRightAnimation(){
            this.currentAnimation = "aimRight"
            this.frame = 67
            this.animationMode = "loop" 
            this.animation = [67]
            this.animationTime = [10]
            this.animationIndex = 0
            this.animationDirection = 1
            this.animationCurrentTime = 0
        }          

        setAimRightDownAnimation(){
            this.currentAnimation = "aimRightDown"
            this.frame = 66
            this.animationMode = "loop" 
            this.animation = [66]
            this.animationTime = [10]
            this.animationIndex = 0
            this.animationDirection = 1
            this.animationCurrentTime = 0
        }          

        setAimDownAnimation(){
            this.currentAnimation = "aimDown"
            this.frame = 65
            this.animationMode = "loop" 
            this.animation = [65]
            this.animationTime = [65]
            this.animationIndex = 0
            this.animationDirection = 1
            this.animationCurrentTime = 0
        }          
        setLadderClimbingAnimation(){
            this.currentAnimation = "ladderClimbingAnimation"
            this.frame = 70
            this.animationMode = "loop" 
            this.animation = [70,71,72]
            this.animationTime = [10,10,10]
            this.animationIndex = 0
            this.animationDirection = 1
            this.animationCurrentTime = 0
        }            

        setLadderAnimation(){
            this.currentAnimation = "ladderAnimation"
            this.frame = 70
            this.animationMode = "loop" 
            this.animation = [70]
            this.animationTime = [10]
            this.animationIndex = 0
            this.animationDirection = 1
            this.animationCurrentTime = 0
        }            
        setJumpingAnimation(){
            this.currentAnimation = "jumpingAnimation"
            this.frame = 61
            this.animationMode = "loop" 
            this.animation = [61]
            this.animationTime = [61]
            this.animationIndex = 0
            this.animationDirection = 1
            this.animationCurrentTime = 0
        }        

        setStandingAnimation(){
            this.currentAnimation = "standingAnimation"
            this.frame = 60
            this.animationMode = "loop" 
            this.animation = [60]
            this.animationTime = [10]
            this.animationIndex = 0
            this.animationDirection = 1
            this.animationCurrentTime = 0
        }        
       setWalkingAnimation(){
            this.currentAnimation = "walkingAnimation"
            this.frame = 60
            this.animationMode = "loop" 
            this.animation = [60,61,62,63,64]
            this.animationTime = [5,5,5,5,5]
            this.animationIndex = 0
            this.animationDirection = 1
            this.animationCurrentTime = 0
        }
        noControllerPressed(){
            if(Controller.Left==false && Controller.Right==false && Controller.Up==false && Controller.Down==false && Controller.Jump==false &&
                Controller.Grenade==false && Controller.ShotGun==false){
                return true
            }
            return false
        }
        updateplayercontrols(){


            // Sprite Animation system
            //
            this.animationCurrentTime+=1
            //console.log(this.animationIndex)
            if(this.animationCurrentTime>this.animationTime[this.animationIndex]){
                this.animationCurrentTime = 0
                this.animationIndex+=this.animationDirection
                if(this.animationIndex>this.animation.length-1){
                    //this.animationIndex = 0
                    if(this.animationMode=="loop"){
                        this.frame = this.animation[0]
                        this.animationIndex = 0
                    }

                    if(this.animationMode=="pingpong"){
                        //this.animationDirection = -1
                    }
                    if(this.animationMode=="playonce"){
                        //this.animationDirection = 0
                        //this.frame=this.animation[0]
                    }
                }
                if(this.animationIndex==0){
                    if(this.animationMode==="pingpong"){
                        this.animationDirection = 1
                    }
                }
                //if(this.animation[this.animationIndex]==25)console.log("ewerwer")
                this.frame = this.animation[this.animationIndex]
                
            }          
            
            // get coordinates on map
            this.pmx = this.px-(this.mcx*this.tw);
            this.pmy = this.py-(this.mcy*this.th);
            this.ptx = Math.floor(this.px/this.tw)
            this.pty = Math.floor(this.py/this.th)
            if(this.optx == this.ptx && this.opty == this.pty ){

                }else{
                mymap.lightTheMap()
                this.optx = this.ptx
                this.opty = this.pty
            }

            //
            // Player animation
            //
            //if(Controller.Up==false && Controller.Down==false){
            if(this.noControllerPressed() && this.currentAnimation!="aimRight")  this.setStandingAnimation()
            
            if(Controller.Left==true && this.currentAnimation=="standingAnimation")this.setWalkingAnimation()
            if(Controller.Right==true && this.currentAnimation=="standingAnimation")this.setWalkingAnimation()
            if(Controller.Left==true && this.currentAnimation=="jumpingAnimation")this.setWalkingAnimation()
            if(Controller.Right==true && this.currentAnimation=="jumpingAnimation")this.setWalkingAnimation()
            if(Controller.Left==true && this.currentAnimation=="aimRight")this.setWalkingAnimation()
            if(Controller.Right==true && this.currentAnimation=="aimRight")this.setWalkingAnimation()

            //}           

//            if(this.playerladdercollision(this.px,this.py) && this.currentAnimation!="ladderAnimation" && this.currentAnimation!="ladderClimbingAnimation"){
//                this.setLadderAnimation()
//            }

            var isOnLadder  = this.playerladdercollision(this.px,this.py)

            if(Controller.Up==true || Controller.Down==true){
                if(isOnLadder){
                    if(this.currentAnimation!="ladderClimbingAnimation"){
                        this.setLadderClimbingAnimation()
                        this.animationCurrentTime=10
                    }
                }                    
            }
//
            if(Controller.Up==false && Controller.Down==false){
                if(isOnLadder ){
                      if(this.currentAnimation!="ladderClimbingAnimation"){
                           this.setLadderAnimation()
                       }
                }else if(this.currentAnimation=="ladderAnimation"){
                            this.setStandingAnimation()
                }
            }

            
            if(isOnLadder){
                // NOTE
                if(Controller.Left==false && Controller.Right==false) this.jump=false;
                this.laddermode();
                this.movespeed = 1;			
                }else{
                    //console.log(mygrowslime.map[Math.floor((this.px/tilewidth)/2)][Math.floor((this.py/tileheight)/2)])
                for(var i=0;i<2;i++){
                    //if(mygrowslime.map[Math.floor((this.px/tilewidth)*2)][Math.floor((this.py/tileheight)*2)]==mymap.tileslime){
                    //this.playerSlimeGravity()
                    //console.log("w")
                    //}else{    
                    this.playergravity();
                    if(mygrowslime.map[Math.floor((this.px/tilewidth)*2)][Math.floor((this.py/tileheight)*2)]==mymap.tileslime)break
                    //}
                }
            }
            // Jump from ladder (hold space and controller l/r)
            if(isOnLadder && Controller.Jump==true){
                //if(this.jump==false){
                    if(Controller.Left==true || Controller.Right==true ){
                        if(this.playerladdercollision(this.px+tilewidth/4,this.py) || this.playerladdercollision(this.px+tilewidth-(tilewidth/10),this.py)){
                            
                            this.incy = -5;
                            this.jump = true;
                        }
                    }
                //}
            }
            

            this.movespeed +=.1;
            if(mygrowslime.map[Math.floor((this.px/tilewidth)*2)][Math.floor((this.py/tileheight)*2)]==mymap.tileslime){
                this.movespeed = 1;
            }
            if(this.movespeed > 4)this.movespeed = 4;
            if(mygrowslime.map[Math.floor((this.px/tilewidth)*2)][Math.floor((this.py/tileheight)*2)]==mymap.tileslime)   {
                this.movespeed=1;
            }         
            
            // if no movement left and right up and down then slow down
            //movement
            if(Controller.Right==false){//Keyboard.KeyDown(Key.Right) = False
                if(Controller.Left==false){//Keyboard.KeyDown(Key.Left) = False			
                    if(Controller.Up==false){//Keyboard.KeyDown(Key.Up) = False
                        if(Controller.Down==false){//Keyboard.KeyDown(Key.Down) = False			
                            this.movespeed = 1;
                        }
                   }
                }
            }
                            
            for(var i=0;i<Math.ceil(this.movespeed);i++){
                if(Controller.Right==true){//Keyboard.KeyDown(Key.Right)
                    if(this.playertilecollision(this.px+1,this.py) == false){
                        this.px+=1;
                        this.scrollmap(1,0);
                    }
                }
                if(Controller.Left==true){//Keyboard.KeyDown(Key.Left)
                    if(this.playertilecollision(this.px-1,this.py) == false){
                        this.px-=1;
                        this.scrollmap(-1,0);
                    }
                }			
            }
            
            if(Controller.Left==true)this.facing="left";//Keyboard.KeyDown(Key.Left) Then facing="left"
            if(Controller.Right==true)this.facing="right";//Keyboard.KeyDown(Key.Right) Then facing="right"
            if(Controller.Up==true)this.facing="up";//Keyboard.KeyDown(Key.Up) Then facing="up"
            if(Controller.Down==true)this.facing="down";//Keyboard.KeyDown(Key.Down) Then facing="down"
            if(Controller.Left==true && Controller.Up==true)this.facing="leftup"
            if(Controller.Left==true && Controller.Down==true)this.facing="leftdown"
            if(Controller.Right==true && Controller.Up==true)this.facing="rightup"
            if(Controller.Right==true && Controller.Down==true)this.facing="rightdown"
            // throw grenade
            if(Controller.Grenade==false)this.gtkd=false;//If Keyboard.KeyDown(Key.G) = False Then gtkd = False
            if(this.gtkd == false && Controller.Grenade==true){//Keyboard.KeyDown(Key.G)
                this.gtkd = true;			
                
                var pcx=this.px+(this.pw/2);
                var pcy=this.py+(this.ph/2);						
                //mygrenade.AddLast(New grenade(this.pcx,this.pcy,this.facing));
                
                mygrenade.push(
                    new grenade(
                        pcx,pcy-tileheight/6,this.facing
                        )
                );
            }
            
            // Fire shotgun
            if(Controller.ShotGun==false)this.sfkd=false;//Keyboard.KeyDown(Key.S) = False Then sfkd = False
            if(this.sfkd == false && Controller.ShotGun==true){//Keyboard.KeyDown(Key.S)
                this.sfkd = true;	
                this.fireshotgun();					
            }

            // Mine left or right
            if(this.minedelay > 0)this.minedelay -= 1;
            if(Controller.Mine==true && this.minedelay<=0){//Keyboard.KeyDown(Key.M) And minedelay <=0
                this.minedelay = 30;
                this.mine();
            }

            if(Controller.LaserWall==true){//If Keyboard.KeyReleased(Key.L)
                Controller.LaserWall=false;
                //mylaserwall.Add(New laserwall(px,py+ph))
                mylaserwall.push(
                    new laserwall(
                        this.px,this.py+this.ph) 
                );
            }
        }
 
        setPositionNearSlimeMonster(){
            for(var y=0;y<mygrowslime.map.length;y+=1){
                for(var x=0;x<mygrowslime.map[0].length;x+=1){
                    if(mygrowslime.map[x][y]==mygrowslime.slimetile){
                        myplayer.px = Math.floor(((x+2)/2)*tilewidth)
                        myplayer.py = Math.floor(((y-4)/2)*tileheight)
                        myplayer.mcx = Math.floor((myplayer.px/tilewidth))
                        myplayer.mcy = Math.floor((myplayer.py/tilewidth))
                        myplayer.mcx-=20
                        myplayer.mcy-=10
                                                
                        break
                    }
                }
            }
            

        }
        createrandominventory(){
		    for(var i=0;i<this.playeritemnames.length;i++){
			    this.playeritem[i][0] = i;
			    this.playeritem[i][1] = Math.floor(Math.random()*65);
            }
        }

        //
        // Mine a block up or down or left or right(key v) drops loot
        //
	    mine(){
            if(this.facing == "left"){
                for(var x=this.px;x>this.px-this.tilewidth;i-=1){// Step -1
                    var x2 = x / tilewidth;
                    var y2 = this.py / tileheight;
                    if(mymap.mapfinal[x2][y2] == mymap.tilemineable){
                        mymap.mapfinal[x2][y2] = mymap.tileempty;
                        this.createmineitem(x2,y2);
                        return;
                    }
                }
            }
            if(this.facing == "right"){
                for(var x=this.px;x<this.px+(tilewidth*2);i++){
                    var x2 = x / tilewidth;
                    var y2 = this.py / tileheight;
                    if(mymap.mapfinal[x2][y2] == mymap.tilemineable){
                        mymap.mapfinal[x2][y2] = mymap.tileempty;
                        this.createmineitem(x2,y2);
                        return;
                    }
                }
            }
            if(this.facingVert == "up"){
                for(var y=this.py;y>this.py-(tileheight*2);y-=1){// Step -1
                    var x2 = this.px / tilewidth;
                    var y2 = y / tileheight;
                    if(mymap.mapfinal[x2][y2] == mymap.tilemineable){
                        mymap.mapfinal[x2][y2] = mymap.tileempty;
                        this.createmineitem(x2,y2);
                        return
                    }
                }
            }	
            if(this.facingVert == "down"){
                for(var y=this.py;y<this.py+tileheight;y++){
                    var x2= this.px / tilewidth;
                    var y2= y / tileheight;
                    if(mymap.mapfinal[x2][y2] == mymap.tilemineable){
                        mymap.mapfinal[x2][y2] = mymap.tileempty;
                        this.createmineitem(x2,y2);
                        return
                    }
                }
            }	
        }
	    createmineitem(x2,y2){		
            x2 *= this.tw;
            y2 *= this.th;
            x2 += this.tw/2;
            y2 += this.th/2;
            for(var i=0;i<Math.floor(Math.random()*3);i++){		
                var item;
                var num=Math.Floor(Math.random()*10);
                if(num>=8)item="Gold"; 
                if(num<8){
                    item="Coal";
                 }else{
                    item="Rock";
                 }		
                //myitem.Add(New item(x2+Rnd(-tw/3,th/3),y2+Rnd(th/3,th/3),item))
            }
	    }
        playerladdercollision(x,y){
            var cx=Math.floor(x/this.tw);
            var cy=Math.floor(y/this.th);
            for(var y2=cy-1;y2<cy+2;y2++){
                for(var x2=cx-1;x2<cx+2;x2++){
                    if(x2>=0 && x2<mapwidth && y2>=0 && y2<mapheight){	            		        
                        if(mymap.mapladder[Math.floor(x2)][Math.floor(y2)] == 1){	                	                     
                            if(this.rectsoverlap(x,y,
                                                this.pw,this.ph,
                                                (x2*this.tw)+this.tw/2,
                                                (y2*this.th),
                                                (this.tw/9),(this.th)) == true){                                    	                    
                                return true;
                            }
                        }
                    }
                }
            }
        
            return false;
        }
	    playertilecollision(x,y){
            var cx=Math.floor(x/this.tw);
            var cy=Math.floor(y/this.th);
            for(var y2=cy-1;y2<cy+2;y2++){
                for(var x2=cx-1;x2<cx+2;x2++){
                    if(x2>=0 && x2<mapwidth && y2>=0 && y2<mapheight){	            		        
                        if(mymap.mapfinal[Math.floor(x2)][Math.floor(y2)] != mymap.tileempty && 
                            mymap.mapfinal[Math.floor(x2)][Math.floor(y2)] != mymap.tileegg ){// 'Or mymap.mapfinal[x2,y2] = mymap.tilemineable           
                                                    
                            if(rectsoverlap(x,y,this.pw,this.ph,x2*this.tw,
                                            y2*this.th,this.tw,this.th) == true){;                                    	                    
                                return true;
                            }
                        }
                    }
                }
            }
    
            return false;
        }
        laddermode(){
            for(var i=0;i<Math.ceil(this.movespeed);i++){
                if(Controller.Right==true){;//Keyboard.KeyDown(Key.Right)
                    if(this.playertilecollision(this.px+1,this.py) == false){
                        if(this.playerladdercollision(this.px+1,this.py) == true){
                            this.px+=1;
                            this.scrollmap(1,0);
                        }
                  }
                }
                if(Controller.Left == true){ //Keyboard.KeyDown(Key.Left)			
                    if(this.playertilecollision(this.px-1,this.py) == false){
                        if(this.playerladdercollision(this.px-1,this.py) == true){
                            this.px-=1;
                            this.scrollmap(-1,0);
                        }
                    }
                }			
                if(Controller.Up == true){//Keyboard.KeyDown(Key.Up)			
                    if(this.playertilecollision(this.px,this.py-1) == false){
                        if(this.playerladdercollision(this.px,this.py-1) == true){
                            this.py-=1;
                            this.scrollmap(0,-1);
                        }
                    }
                }			
                if(Controller.Down == true){//Keyboard.KeyDown(Key.Down)			
                    if(this.playertilecollision(this.px,this.py+1) == false){
                        if(this.playerladdercollision(this.px,this.py+1) == true){			
                            this.py+=1;
                            this.scrollmap(0,1);
                        }
                    }
                }					  			  	
            }
        }
        scrollmap(x,y){ 
            if(x==-1)this.mox+=1;
            if(x==1)this.mox-=1;
            if(y==-1)this.moy+=1;
            if(y==1)this.moy-=1;
            if(this.mox>this.tw-1){
                this.mcx-=1;
                this.mox=0;
            }
            if(this.mox<-(this.tw-1)){
                this.mcx+=1;
                this.mox=0;
            }
            if(this.moy>this.th-1){
                this.mcy-=1;
                this.moy=0;
            }
            if(this.moy<-(this.th-1)){
                this.mcy+=1;
                this.moy=0;
            }
        }
        playerSlimeGravity(){
            if(this.jump == false && this.playertilecollision(this.px,this.py+1) == false){ 
                this.jump = true;
                this.incy = 0;
            }
            if(this.jump == false && Controller.Jump==true){//Keyboard.KeyDown(Key.Space) = True
                this.incy = -5;
                this.jump = true;
            }
            //If the player is in the jump
            if(this.jump == true){
                this.incy += 0.1;
                //if the player is going up
                if(this.incy <=0){
                    for(var i= 0;i<Math.abs(this.incy);i++){                
                        this.py -= 1;
                        this.scrollmap(0,-1);
                        if(this.playertilecollision(this.px,this.py-1) == true){
                            this.incy = 0;
                            break;
                        }
                    }
                }
                // if the player if going down
                if(this.incy > 0){
                    for(var i= 0;i< this.incy;i++){
                        this.py += 1;
                        this.scrollmap(0,1);
                        //if the player touches the ground
                        if(this.playertilecollision(this.px,this.py+1) == true){
                            this.jump = false;                        
                            break;
                        }
                    }
                    if(this.incy>2)this.incy=2;
                }
            }
        }        
        playergravity(){
            if(this.jump==true && this.currentAnimation!="jumpingAnimation")this.setJumpingAnimation()
            if(this.jump == false && this.playertilecollision(this.px,this.py+1) == false){ 
                this.jump = true;
                this.incy = 0;
            }
            if(this.jump == false && Controller.Jump==true){//Keyboard.KeyDown(Key.Space) = True
                this.incy = -5;
                this.jump = true;
            }
            //If the player is in the jump
            if(this.jump == true){
                this.incy += 0.1;
                //if the player is going up
                if(this.incy <=0){
                    for(var i= 0;i<Math.abs(this.incy);i++){                
                        this.py -= 1;
                        this.scrollmap(0,-1);
                        if(this.playertilecollision(this.px,this.py-1) == true){
                            this.incy = 0;
                            break;
                        }
                    }
                }
                // if the player if going down
                if(this.incy > 0){
                    for(var i= 0;i< this.incy;i++){
                        this.py += 1;
                        this.scrollmap(0,1);
                        //if the player touches the ground
                        if(this.playertilecollision(this.px,this.py+1) == true){
                            this.jump = false;                        
                            break;
                        }
                    }
                    if(this.incy>4)this.incy=4;
                }
            }
        }
        fireshotgun(){
            //console.log("Fire routine"+Controller.Left+","+Controller.Up)
            var angle=0;
            if(this.facing=="left"){
                angle = Math.PI;
                this.setAimRightAnimation()
            }
            if(this.facing=="right"){
                angle = 0;
                this.setAimRightAnimation()
            }
            if(this.facing=="up"){
                angle = Math.PI*1.55+randomRangeFloat(-0.2,0.2);
                this.setAimUpAnimation()
            }
            if(this.facing=="down"){
                angle = Math.PI/2+randomRangeFloat(-0.2,0.2);
                this.setAimDownAnimation()
            }
            if(this.facing=="leftup"){
            //if(Controller.Left==true && Controller.Up==true){
                
                angle = -Math.PI/1.2
                this.setAimRightUpAnimation()
                
            }else
                //if(Controller.Right==true && Controller.Up==true){
                    if(this.facing=="rightup"){
                angle = -Math.PI/4
                this.setAimRightUpAnimation()
            }else

                //if(Controller.Right==true && Controller.Down==true){
                if(this.facing=="rightdown"){
                angle = Math.PI/4
                this.setAimRightDownAnimation()
            }else

                //if(Controller.Left==true && Controller.Down==true){
                if(this.facing=="leftdown"){
                angle = Math.PI-Math.PI/4
                this.setAimRightDownAnimation()

            }

            
            /*
            Select facing
                Case "left"
                    angle=Pi
                Case "right"
                    angle=0
                Case "up"
                    'Print Pi*1.5
                    angle=Pi*1.55+Rnd(-.2,.2)
                    
                Case "down"
                    angle = Pi/2+Rnd(-.2,.2)
            End Select
            */
            var posx = (this.px+this.pw/2)+(Math.cos(angle)*16)
            var posy = (this.py+this.ph/2)+(Math.sin(angle)*16)
            for(var i=0;i<7;i++){
                mybullet.push(
                    new bullet(
                        posx,posy-4,angle+randomRangeFloat(-.1,.1),"player","shotgun"
                        )
                );
                
                //mybullet.AddLast(New bullet(px,py,angle+Rnd(-.1,.1),"player","shotgun"))
            }
        }
        // player draw routine - all tile map game
	    draw(){
            //console.log(myplayer.ptx+","+myplayer.optx+"||"+myplayer.pty+","+myplayer.opty)   
            
            ctx.globalAlpha = 1;
            //canvas.Scissor = New Recti(32,32,screenwidth-32,screenheight-64)
            //draw the map
            //ctx.fillStyle='rgb(90,90,200)';
            //ctx.fillRect(0,0,50,50);

            //canvas.BlendMode = BlendMode.Opaque
            for(var y=-1;y<this.maptilesheight;y++){

                for(var x=-1;x<this.maptileswidth;x++){
                    var x2=this.mcx+x;
                    var y2=this.mcy+y;
                    
                    var x3=(x*this.tw)+this.mox;
                    var y3=(y*this.th)+this.moy;
                    
                    
                    if(x2<0 || x2>=mapwidth || y2<0 || y2>=mapheight)continue;		
                    ctx.globalAlpha = 1.0-mymap.lightmap2[x2][y2]
                    //if(x2<this.mcx-2 || x2>this.mcx+40 || y2<this.mcy-2 || y2>this.mcy+40)continue
                    
                    // NOTE : Gradient background.
                    //
                    if(y2<17){
                        //canvas.Color = Color.White
                        //canvas.DrawImage(mygradienttile.image[y2],x3,y3)
                        ctx.fillStyle='rgb(90,90,200)';
                        ctx.fillRect(x3,y3,this.tw,this.th);
                    }
                    
                    //if(mymap.tilemap[x2][y2]>=0 && mymap.tilemap[x2][y2]<=2){
                    if(y2>16){
                        //if(mymap.tilemap[x2][y2]>30)console.log(mymap.tilemap[x2][y2])
                        //ctx.globalAlpha = mymap.[x2][y2]
                        if(mymap.lightmap[x2][y2]==0){// && mymap.tilemap[x2][y2]!=21){
                            drawTile(x3,y3,mymap.tilemap[x2][y2])
                        }
                        //if(Math.random ()<.01)console.log(mymap.tilemap[x2][y2])
                        if(mymap.lightmap[x2][y2]>0){
                            ctx.globalAlpha = 1.0-(mymap.lightmap[x2][y2])
                            drawTile(x3,y3,mymap.tilemap[x2][y2])
                            //if(Math.random ()<.01)console.log(mymap.tilemap[x2][y2]) 
                            ctx.globalAlpha = 1
                        }
                        
                    }
                    
                    if(mymap.mapfinal[x2][y2]== mymap.tileturret){
                        //canvas.OutlineMode=OutlineMode.Solid
                        //canvas.OutlineColor = Color.Black
                        //canvas.OutlineWidth = 1						
                        //canvas.Color = Color.Grey
                        //canvas.DrawRect(x3,y3,tw,th)	
                        //canvas.OutlineMode=OutlineMode.None
                        ctx.fillStyle = 'grey';
                        ctx.fillRect(x3,y3,this.tw,this.th);
                    }
                   

                    
                    //draw the slime			
                    for(var y4=0;y4< 2;y4++){
                       for(var x4=0;x4< 2;x4++){
                            if(mygrowslime.map[Math.floor((x2*2)+x4)][Math.floor((y2*2)+y4)] == 10){
                                //canvas.Color = Color.Green
                                //canvas.DrawRect(x3+(x4*(mygrowslime.tw)),y3+(y4*(mygrowslime.th)),mygrowslime.tw,mygrowslime.th)
                                // Draw the slime using the light flooding, but at .5 the effect
                                ctx.globalAlpha = 1.0-(mymap.lightmap2[x2][y2]/2)
                                ctx.fillStyle = 'green';
                                ctx.fillRect(x3+(x4*(mygrowslime.tw)),y3+(y4*(mygrowslime.th)),mygrowslime.tw,mygrowslime.th);
                             }
                        }
                    }
                    

                }
            }


            // draw the buildings
            ctx.globalAlpha = 1
            for(var i=0;i<buildmap.length;i+=1){
                //console.log(distanceM(buildmap[i],10*tileheight,this.px,this.py))
                if (distanceM(buildmap[i],10*tileheight,this.px,this.py)<screenwidth){
                var x1=buildmap[i];
                var y1=13*tileheight;
                var x2=(x1-(this.mcx*this.tw))+this.mox;
                var y2=(y1-(this.mcy*this.th))+this.moy;
                mybuilding[i].draw(ctx,x2,y2)                    
                }
            }

            

            

            if(developmode){
                for(var i=0;i<mygrowslime.openx.length;i++){
                    var x1=mygrowslime.openx[i]*tilewidth/2
                    var y1=mygrowslime.openy[i]*tileheight/2
                    var x2=(x1-(this.mcx*this.tw))+this.mox;
                    var y2=(y1-(this.mcy*this.th))+this.moy;

                //var x1=mytownperson[i].px;
                //var y1=mytownperson[i].py;
                //var x2=(x1-(this.mcx*this.tw))+this.mox;
                //var y2=(y1-(this.mcy*this.th))+this.moy;
                    ctx.globalAlpha = 0.5
                    ctx.fillStyle="red"
                    ctx.fillRect(x2,y2,tilewidth/2,tileheight/2)
                }
            }
            ctx.globalAlpha=1



            //Draw the ladders		
            for(var y=-1;y<this.maptilesheight;y++){
                for(var x=-1;x<this.maptileswidth;x++){

                    var x2=this.mcx+x;
                    var y2=this.mcy+y;
                    var x3=(x*this.tw)+this.mox;
                    var y3=(y*this.th)+this.moy;
                    //if(x2<this.mcx-2 || x2>this.mcx+40 || y2<this.mcy-2 || y2>this.mcy+40)continue
                    if(x2>=0 && x2<mapwidth && y2>=0 && y2<mapheight){
                        if(mymap.mapladder[x2][y2] == 1){
                            //canvas.Color = Color.Brown
                            //canvas.DrawRect(x3,y3,tw,th)
                            //canvas.Color = Color.Red
                            //canvas.DrawRect(x3,y3,tw/4,th/3)
                            //ctx.fillStyle = 'brown';
                            //ctx.fillRect(x3,y3,this.tw,this.th);
                            //ctx.fillStyle = 'red';
                            //ctx.fillRect(x3+this.tw/6,y3,this.tw/4,this.th/3);
                            
                            if(y2>16)ctx.drawImage(tileImage,0,0,32,32,x3,y3,tilewidth,tileheight);
                            ctx.drawImage(tileImage,416,48,32,32,x3,y3,tilewidth,tileheight);

                        }
                    }
                }
            }

            /*
            '
            ''Draw the trees
            '
            canvas.Color = Color.White		
            For var i:=Eachin mytree
                'If Rnd(100)<10 Then Print Millisecs()
                var x2:Int=i.px-mcx*tw+mox
                var y2:Int=i.py-mcy*th+moy
                'i.draw(canvas,x2,y2)
                canvas.DrawImage(i.image,x2,y2)
                'canvas.Color = i.col
                'canvas.DrawText(i.number,x2,y2)
            Next
                    
            '
            ''Draw the buildings
            '
            canvas.Color = Color.White
            For Local i:=Eachin mybuilding
                Local x2:Int=i.px-mcx*tw+mox
                Local y2:Int=i.py-mcy*th+moy
                i.draw(canvas,x2,y2)
                'canvas.Color = i.col
                'canvas.DrawText(i.number,x2,y2)
            Next
            */
            //draw towns people

            for(var i=0;i<mytownperson.length;i++){
                if(mytownperson[i].inRange==false)continue
                var x1=mytownperson[i].px;
                var y1=mytownperson[i].py;
                var x2=(x1-(this.mcx*this.tw))+this.mox;
                var y2=(y1-(this.mcy*this.th))+this.moy;
                ctx.fillStyle = 'black';
                ctx.fillRect(x2,y2,this.tw,this.th);
                ctx.fillStyle = 'green';
                ctx.fillRect(x2+1,y2+1,this.tw-2,this.th-2);
                
                //canvas.OutlineMode=OutlineMode.Solid
                //canvas.OutlineColor = Color.Black
                //canvas.OutlineWidth = 1				
                //canvas.Color = Color.Green
                //canvas.DrawRect(x2,y2,tw,th)
                //canvas.OutlineMode = OutlineMode.None
                this.drawpowerbar(x2,y2,mytownperson[i].hp,mytownperson[i].hpmax);
                //'canvas.Color = Color.White
                //'canvas.DrawText(i.state,x2,y2)
                //'canvas.DrawText(i.substate,x2,y2+12)
                //'canvas.DrawText(i.x*i.w+","+i.y*i.h,x2,y2+22)
                //'canvas.DrawText(i.px+","+i.py,x2,y2+37)
            }
            

            //draw eggs
            //ctx.save()
            
            for(var i=0;i<myegg.length;i++){
                if(myegg[i].inRange==false)continue
                var x1=myegg[i].px;
                var y1=myegg[i].py;
                var x2=(x1-(this.mcx*this.tw))+this.mox;
                var y2=(y1-(this.mcy*this.th))+this.moy;
               // ctx.globalAlpha = 1.0-mymap.lightmap2[Math.floor(x1/tilewidth)][Math.floor(y1/tileheight)]

                //var x2=(x1-(this.mcx*this.tw))+this.mox;
                //var y2=(y1-(this.mcy*this.th))+this.moy;
                //canvas.Color = Color.Red
                //canvas.DrawRect(x2,y2,tw,th)
                //ctx.fillStyle = 'red';
                //ctx.fillRect(x2,y2,this.tw,this.th);
                //console.log(x2+','+y2)
                //console.log(myegg[i].brightness)
                //ctx.filter = "brightness("+
            //            myegg[i].brightness
                //            +"%)"
                //ctx.filter = "brightness(400%)"
                drawSprite(x2,y2,myegg[i].frame)
  

                //ctx.fillStyle="white"
                //ctx.fillRect(x2,y2,this.tw,this.th);
                //this.drawpowerbar(x2,y2,myflyingmonster[i].hp,myflyingmonster[i].hpmax);
                //canvas.Color = Color.White
                //canvas.DrawText(i.state,x2,y2)
                //canvas.DrawText(i.substate,x2,y2+12)
                //canvas.DrawText(i.x*i.w+","+i.y*i.h,x2,y2+22)
                //canvas.DrawText(i.px+","+i.py,x2,y2+37)                
            }
            ctx.globalAlpa = 1
            //ctx.filter = "brightness(100%)"
            //ctx.restore()



            // Draw the player
            this.pmx = (this.px-(this.mcx*this.tw))+this.mox;
            this.pmy = (this.py-(this.mcy*this.th))+this.moy;
            //canvas.Color = Color.White
            //canvas.DrawRect(pmx,pmy,pw,ph)
            //ctx.fillStyle = 'white';
            //ctx.fillRect(this.pmx,this.pmy,this.pw,this.ph);
            this.drawpowerbar(this.pmx,this.pmy-6,this.hp,this.hpmax);
            var a = -1
            if(this.facing=="left" || this.facing=="leftdown" || this.facing=="leftup"){
                a=-1
            }else{
                a=1
            }            
            drawSprite(this.pmx,this.pmy,this.frame,a)
            


            //draw flying monsters	
            for(var i=0;i<myflyingmonster.length;i++){
                if(myflyingmonster[i].inRange==false)continue
                var x1=myflyingmonster[i].px;
                var y1=myflyingmonster[i].py;
                var x2=(x1-(this.mcx*this.tw))+this.mox;
                var y2=(y1-(this.mcy*this.th))+this.moy;
                //canvas.Color = Color.Red
                //canvas.DrawRect(x2,y2,tw,th)
                //ctx.fillStyle = 'red';
                //ctx.fillRect(x2,y2,this.tw,this.th);
                var a=false

                if(myflyingmonster[i].animationFacing=="left"){
                    a=-1
                }else{
                    a=1
                }
                drawSprite(x2,y2,myflyingmonster[i].frame,a)
                this.drawpowerbar(x2,y2,myflyingmonster[i].hp,myflyingmonster[i].hpmax);
                
                //canvas.Color = Color.White
                //canvas.DrawText(i.state,x2,y2)
                //canvas.DrawText(i.substate,x2,y2+12)
                //canvas.DrawText(i.x*i.w+","+i.y*i.h,x2,y2+22)
                //canvas.DrawText(i.px+","+i.py,x2,y2+37)                
            }
            

            
            //draw the walking monsters		
            for(var i=0;i<mywalkingmonster.length;i++){
                if(mywalkingmonster[i].inRange==false)continue
                var x1=mywalkingmonster[i].px;
                var y1=mywalkingmonster[i].py;
                var x2=(x1-(this.mcx*this.tw))+this.mox;
                var y2=(y1-(this.mcy*this.th))+this.moy;
                //canvas.Color = Color.Red
                //canvas.DrawRect(x2,y2,tw,th)
                //ctx.fillStyle = 'red';
                //ctx.fillRect(x2,y2,this.tw,this.th);
                var a=false

                if(mywalkingmonster[i].animationFacing=="left"){
                    a=-1
                }else{
                    a=1
                }
                drawSprite(x2,y2,mywalkingmonster[i].frame,a)
                //ctx.globalAlpha = .3
                //ctx.fillStyle = 'white';
                //ctx.fillRect(x2,y2+4,this.tw,this.th-16);
                //ctx.globalAlpha=1
                this.drawpowerbar(x2,y2,mywalkingmonster[i].hp,mywalkingmonster[i].hpmax);	
                //ctx.fillStyle='white'
                //ctx.fillText(mywalkingmonster[i].state+"-"+mywalkingmonster[i].substate,x2,y2)
                //canvas.Color = Color.White
                //canvas.DrawText(i.state,x2,y2)
                //canvas.DrawText(i.substate,x2,y2+12)
                //canvas.DrawText(i.x*i.w+","+i.y*i.h,x2,y2+22)
                //canvas.DrawText(i.px+","+i.py,x2,y2+37)                
            }
            
            
            
            // Draw the bullets
            //
            //canvas.OutlineMode=OutlineMode.Solid
            //canvas.OutlineColor = Color.Grey
            //canvas.OutlineWidth = 1					
            //canvas.Color = Color.Yellow
            ctx.fillStyle = 'yellow';
            //For Local i:=Eachin mybullet
            for(var i=0;i<mybullet.length;i++){
                var x2=mybullet[i].px-this.mcx*this.tw+this.mox;
                var y2=mybullet[i].py-this.mcy*this.th+this.moy;
                //canvas.DrawCircle(x2,y2,i.w)
                ctx.fillRect(x2,y2,mybullet[i].w,mybullet[i].w);

            }
            

            
            // Draw the grenades
            //
            //canvas.Color = Color.Titanium
            
            //For Local i:=Eachin mygrenade
            for(var i=0;i<mygrenade.length;i++){
                
                var x2=mygrenade[i].px-this.mcx*this.tw+this.mox;
                var y2=mygrenade[i].py-this.mcy*this.th+this.moy;
                //canvas.DrawCircle(x2,y2,4)
                ctx.fillStyle = 'rgb(250,250,250)';
                ctx.fillRect(x2,y2,4,4);
                ctx.fillStyle = 'rgb(50,50,50)';
                ctx.fillRect(x2+1,y2+1,2,2);
            }
            

            
            // Draw the fragmentation 
            //
            //canvas.Color = Color.Gold
            ctx.fillStyle = 'gold';
            //For Local i:=Eachin myfrag
            for(var i=0;i<myfrag.length;i++){
                var x2=myfrag[i].px-this.mcx*this.tw+this.mox;
                var y2=myfrag[i].py-this.mcy*this.th+this.moy;
                //canvas.DrawCircle(x2,y2,3)
                ctx.fillRect(x2,y2,3,3);
                
            }
            

            
            // Draw the items
            //
            //canvas.Color = Color.Red
            ctx.fillStyle = 'red';
            //For Local i:=Eachin myitem
            for(var i=0;i<myitem.length;i++){
                if(myitem[i].inRange==false)continue
                var x2=myitem[i].px-this.mcx*this.tw+this.mox;
                var y2=myitem[i].py-this.mcy*this.th+this.moy;			
                
                //canvas.DrawCircle(x2,y2,3)
                ctx.fillRect(x2,y2,3,3);
            }
            

            
            //
            //Draw the tentacles 
            //
            //For Local i:=Eachin mytentacle
            for(var i=0;i<mytentacle.length;i++){
                var x1=mytentacle[i].basex-this.mcx*this.tw+this.mox;
                var y1=mytentacle[i].basey-this.mcy*this.th+this.moy;			
                var x2=mytentacle[i].topx-this.mcx*this.tw+this.mox;
                var y2=mytentacle[i].topy-this.mcy*this.th+this.moy;	

                //var x2=myitem[i].px-this.mcx*this.tw+this.mox;
                //var y2=myitem[i].py-this.mcy*this.th+this.moy;		
                //canvas.Color = Color.Green
                
                //canvas.DrawLine(x1+x3,y1+y3,x2+x3,y2+y3)
                drawLine(x1,y1,x2,y2,'green',4);
                //console.log(+mytentacle[i].basex+ ', '+mytentacle[i].basey)
                if(mytentacle[i].grabbed == true){
                    //canvas.Color = Color.Red
                    //canvas.DrawRect(x2-(tilewidth/2),y2-(tileheight/2),tilewidth,tileheight)
                    ctx.fillStyle = 'red';
                    ctx.fillRect(x2-(tilewidth/2),y2-(tileheight/2),tilewidth,tileheight);
                }
            }
            
            //canvas.OutlineMode=OutlineMode.None	
            
            
            
            // Draw the laser walls
            
            //For Local i:=Eachin mylaserwall
            for(var i=0;i<mylaserwall.length;i++){
                if(mylaserwall[i].inRange==false)continue
                var x2=mylaserwall[i].tx-this.mcx*this.tw+this.mox;
                var y2=mylaserwall[i].ty-this.mcy*this.th+this.moy;
                var h=mylaserwall[i].by-mylaserwall[i].ty
                //canvas.Color = Color.Yellow
                //canvas.DrawRect(x2-2,y2,4,h)
                //canvas.Color = Color.Red
                //canvas.DrawRect(x2-4,y2,8,4)
                //canvas.DrawRect(x2-4,y2+h-4,8,4)
                ctx.fillStyle = 'yellow';
                ctx.fillRect(x2-2,y2,4,h);
                ctx.fillStyle = 'yellow';
                ctx.fillRect(x2-4,y2,8,4);
                ctx.fillRect(x2-4,y2+h-4,8,4);
            }
            

            
            //
            //Draw the falling numbers
            //
            for(var i=0;i<mynumberfall.length;i++){
                var x2=mynumberfall[i].px-this.mcx*this.tw+this.mox;
                var y2=mynumberfall[i].py-this.mcy*this.th+this.moy;
                //canvas.Color = i.col
                //canvas.DrawText(i.number,x2,y2)
                ctx.fillStyle = 'red';
                ctx.fillText(mynumberfall[i].number,x2,y2);
            }
            //
            //Draw the flashing effect
            //
            for(var i=0;i<myflashingeffect.length;i++){
                var x2=myflashingeffect[i].x-this.mcx*this.tw+this.mox;
                var y2=myflashingeffect[i].y-this.mcy*this.th+this.moy;
                ctx.fillStyle = 'white'
                ctx.globalAlpha = myflashingeffect[i].alpha 
                ctx.fillRect(x2,y2,tilewidth,tileheight)
                
            }            
            

            
        }

	    drawpowerbar(x,y,hp,hpmax){
            if(hp<0)return;
            var powerbarlen=this.pw;
            var cpos=(powerbarlen/hpmax)*hp;
            //canvas.Color = Color.Black
            //canvas.DrawRect(x,y,powerbarlen,5)
            ctx.fillStyle='black';
            ctx.fillRect(x,y,powerbarlen,5);
            if(hp >= hpmax/2){
                //canvas.Color = Color.Green
                ctx.fillStyle = 'green';
            }else if(hp<hpmax/2 && hp>hpmax/4){
                //canvas.Color = Color.Yellow
                ctx.fillStyle = 'yellow';
            }else{
                //canvas.Color = Color.Red
                ctx.fillStyle = 'red';
            }
            //canvas.DrawRect(x+1,y+1,cpos,3)
            ctx.fillRect(x+1,y+1,cpos,3);
        }
        rectsoverlap(x1,y1,w1,h1,x2,y2,w2,h2){
            if( x1 >= (x2 + w2) || (x1 + w1) <= x2)return false;
            if( y1 >= (y2 + h2) || (y1 + h1) <= y2)return false;
            return true;
        }
    }

    

    // Our map system inc overview map view
    class map{

        constructor(sw,sh,mw,mh,full=true){
            this.tw,this.th;
            this.mw,this.mh;
            this.sw,this.sh,this.mmh,this.mmw//'mmh is actual finalmap size
            this.map=[];//New Int[1,1]
            this.mapfinal=[];//New Int[1,1]
            this.mapladder=[];//New Int[1,1]
            this.numScreenTilesHor = Math.floor(screenwidth / tilewidth)
            this.numScreenTilesVer = Math.floor(screenheight / tileheight)
            //this.mapimage:Image
            //this.mapcanvas:Canvas
            //this.mapladderimage:Image
            //this.mapladdercanvas:Canvas
            this.mapdoor=[];//New Int[1,1]
            //this.maptilevariation=[];//New Int[1,1]
            this.tilesolid=0;
            this.tileempty=1;
            this.tileegg=3;
            this.tileturret=4;
            this.tileslime=10;
            this.tilemineable=50;
            
            this.mmw = mw;
            this.mmh = mh;
            this.mw = Math.floor(mw/3);
            this.mh = Math.floor(mh/3);		
            this.sw = sw;
            this.sh = sh;

            //this.lightmap = []
            //mapimage = New Image(sw,sh)
            //mapcanvas = New Canvas(mapimage)
            //mapladderimage = New Image(sw,sh)
            //mapladdercanvas = New Canvas(mapladderimage)
            //this.maptilevariation = create2DArray(mapwidth,mapheight);//New Int[mapwidth,mapheight]
            //for(var y=0;y<mapheight;y++){
            //    for(var x=0;x<mapwidth;x++){
            //        this.maptilevariation[x][y] = Math.floor(Math.random()*4);
            //    }
            //}
            this.tw = this.sw/this.mmw;
            this.th = this.sh/this.mmh;
            //map = New Int[mw,mh]
            this.map = create2DArray(this.mmw,this.mmh); 
            this.mapfinal = create2DArray(this.mmw,this.mmh);

            this.mapladder = create2DArray(this.mmw,this.mmh);
            this.mapdoor = create2DArray(this.mmw,this.mmh);
            this.lightmap = create2DArray(this.mmw,this.mmh);
            //mapfinal = New Int[mmw,mmh]
            //mapladder = New Int[mmw,mmh]
            //mapdoor = New Int[mmw,mmh]
            this.makemap();
            this.finalizemap();
            if(full==false)return
            for(var i=0;i<1000;i++){
                var x=randomRange(2,this.mmw-4);
                var y=randomRange(17,this.mmh-4);
                if(this.mapfinal[x][y] == 1){
                    // add egg to the map
                    if(this.mapfinal[x][y+1] == 0){
                        this.mapfinal[x][y] = this.tileegg;
                        
                    }
                }
            }	
            //NOTE:
            this.createfinalmineable();
            this.updateladderimage();
            this.updateimage();

            this.tilemap = []
            this.tilemap = create2DArray(this.mmw,this.mmh)
            this.lightmap = []
            this.lightmap = create2DArray(this.mmw,this.mmh)

            this.makeTilemap()
            //for(var y=0;y<this.mmh;y+=1){
            //for(var x=0;x<this.mmw;x+=1){
            //    if(this.tilemap[x][y]==42)console.log("asdasdasd")
            //}}
            this.lightmap2 = create2DArray(this.mmw,this.mmh)
            this.lightTheMap()

        }
        
        lightTheMap(){
            
            if(myplayer==null)return
            
            var tx = Math.floor(myplayer.px / tilewidth)
            var ty = Math.floor(myplayer.py  / tileheight)
            var d = Math.floor(myplayer.maptileswidth)
            if(myplayer.maptilesheight>myplayer.maptileswidth)d=Math.floor(myplayer.maptilesheight)
            var m = 0.055
            //if(myplayer.maptileswidth>myplayer.maptilesheight && myplayer.maptileswidth<20)m=myplayer.maptileswidth/150
            //if(myplayer.maptilesheight>myplayer.maptileswidth && myplayer.maptilesheight<20)m=myplayer.maptilesheight/150
            if(myplayer.maptilesheight>myplayer.maptileswidth)m = 1.0/(myplayer.maptilesheight/1.65)
            
            if(myplayer.maptileswidth>myplayer.maptilesheight)m = 1.0/(myplayer.maptileswidth/1.65)
            //console.log(m + ","+myplayer.maptilesheight)
            
            if(myplayer.pty<20){
                d*=2
                m/=3
            }
            
            //console.log(d)
            for(var y=ty-d;y<ty+d;y+=1){
            for(var x=tx-d;x<tx+d;x+=1){
                if(x>=0 && x<this.mmw && y>=0 && y<this.mmh){
                    if(this.canLightTile(x,y)==true) mymap.lightmap2[x][y]=1
                }
            }}
            //console.log("state")
            var openlist = []
            openlist.push({x:tx,y:ty})
            this.lightmap2[tx][ty] = 0.1
            var lval = 0.1
            
            while(openlist.length>0){
                var x1 = openlist[0].x
                var y1 = openlist[0].y
                //console.log(openlist.length+"."+this.lightmap2[x1][y1]+","+x1+","+y1)
                openlist.shift()

                if(this.lightmap2[x1][y1]>=0.90)break
                if(x1-1>=0 && this.canLightTile(x1-1,y1)==true && this.lightmap2[x1-1][y1]==1){
                    this.lightmap2[x1-1][y1] = this.lightmap2[x1][y1]+m
                    openlist.push({x:x1-1,y:y1})
                }
                if(x1+1<this.mmw && this.canLightTile(x1+1,y1)==true  && this.lightmap2[x1+1][y1]==1){
                    this.lightmap2[x1+1][y1] = this.lightmap2[x1][y1]+m
                    openlist.push({x:x1+1,y:y1})
                }
                if(y1-1>=0 && this.canLightTile(x1,y1-1)==true  && this.lightmap2[x1][y1-1]==1){
                    this.lightmap2[x1][y1-1] = this.lightmap2[x1][y1]+m
                    openlist.push({x:x1,y:y1-1})
                }
                if(y1+1<this.mmh && this.canLightTile(x1,y1+1)==true  && this.lightmap2[x1][y1+1]==1){
                    this.lightmap2[x1][y1+1] = this.lightmap2[x1][y1]+m
                    openlist.push({x:x1,y:y1+1})
                }


            }
            
        }
        canLightTile(x,y){
            if(this.mapfinal[x][y]==mymap.tileegg)return true
            if(this.mapfinal[x][y]==mymap.tileempty)return true
            if(this.mapfinal[x][y]==mymap.tileslime)return true
            return false
        }
        addAllEggsFromMap(){
            for(var y=0;y<this.mmh;y+=1){
                for(var x=0;x<this.mmw;x+=1){
                    if(this.mapfinal[x][y]==this.tileegg){
                        myegg.push(new egg(x,y));
                        //myegg[myegg.length-1].frame=3;
                    }
                }
            }
        }
        makeTilemap(){
            //this.tilesolid=0;
            //this.tileempty=1;
            //this.tileegg=3;
            //this.tileturret=4;
            //this.tileslime=10;
            //this.tilemineable=50;
            for(var y=0;y<this.mmh;y+=1){
                for(var x=0;x<this.mmw;x+=1){
                    // cave background
                    if(this.mapfinal[x][y]==this.tileempty){
                        this.tilemap[x][y] = this.randomBag([0,1,2])
                    }
                    // cave solid
                    if(this.mapfinal[x][y]==this.tilesolid){
                        this.tilemap[x][y] = this.randomBag([20,21])
                        
                    }
                }
            }
            // shadow pass
            for(var y=0;y<this.mmh;y+=1){
                for(var x=0;x<this.mmw;x+=1){
                    // shadow cave background if on its left
                    // is a solid tile
                    if(this.mapBound(x-1,y) && this.mapfinal[x][y]==this.tileempty && this.mapfinal[x-1][y]==this.tilesolid){
                        this.tilemap[x][y] = this.randomBag([6,7,8])
                    }
                    // shadow cave background if above empty is solid tile  
                    if(this.mapBound(x,y-1) && this.mapfinal[x][y]==this.tileempty && this.mapfinal[x][y-1]==this.tilesolid){
                        this.tilemap[x][y] = this.randomBag([12,13,14])
                    }

                }
            }
            // light surface pass
            for(var y=0;y<this.mmh;y+=1){
                for(var x=0;x<this.mmw;x+=1){
                    if(this.mapBound(x,y-1) && this.mapfinal[x][y]==this.tilesolid && this.mapfinal[x][y-1]==this.tileempty){
                        this.tilemap[x][y] = this.randomBag([24])
                    }
                    if(this.mapBound(x,y-1) && this.mapfinal[x][y]==this.tilesolid && this.mapfinal[x][y-1]==this.tileegg){
                        this.tilemap[x][y] = this.randomBag([24])
                    }
                }
            }
            // shadow corners
            for(var y=0;y<this.mmh;y+=1){
                for(var x=0;x<this.mmw;x+=1){
                    if( this.mapBound(x-1,y)==true && 
                        this.mapBound(x,y-1)==true && 
                        this.mapfinal[x][y]     ==  this.tileempty && 
                        this.mapfinal[x-1][y-1]   ==  this.tilesolid &&
                        this.mapfinal[x][y-1]   ==  this.tileempty &&
                        this.mapfinal[x-1][y]   ==  this.tileempty){
                        this.tilemap[x][y] = this.randomBag([3,4,5])
                    }
                    if( this.mapBound(x-1,y)==true && 
                        this.mapBound(x,y-1)==true && 
                        this.mapfinal[x][y]     ==  this.tileempty && 
                        this.mapfinal[x-1][y]   ==  this.tilesolid &&
                        this.mapfinal[x][y-1]   ==  this.tilesolid &&
                        this.mapfinal[x-1][y-1]   ==  this.tilesolid){
                        this.tilemap[x][y] = this.randomBag([9,10,11])
                    }
                    if( this.mapBound(x-1,y)==true && 
                        this.mapBound(x,y-1)==true && 
                        this.mapfinal[x][y]     ==  this.tileempty && 
                        this.mapfinal[x-1][y]   ==  this.tileempty &&
                        this.mapfinal[x][y-1]   ==  this.tilesolid &&
                        this.mapfinal[x-1][y-1]   ==  this.tileempty){
                        this.tilemap[x][y] = this.randomBag([15,16,17])
                    }

                }
            }
            // Gold ore vains
            for(var y=0;y<this.mmh;y+=1){
                for(var x=0;x<this.mmw;x+=1){
                    if(  
                        this.mapBound(x,y-1)==true && this.mapBound(x,y+1)==true &&
                        this.mapfinal[x][y]     ==  this.tilemineable && 
                        this.mapfinal[x][y-1]   ==  this.tilemineable && 
                        this.mapfinal[x][y+1]   ==  this.tilemineable){
                        this.tilemap[x][y] = this.randomBag([40,41])                      
                    }

                    if(  
                        this.mapBound(x,y-1)==true && 
                        this.mapfinal[x][y]     ==  this.tilemineable && 
                        this.mapfinal[x][y-1]   ==  this.tilesolid){

                        this.tilemap[x][y] = this.randomBag([42,43])   //42 43
                                            
                    }
                    if(  
                        this.mapBound(x,y+1)==true && 
                        this.mapfinal[x][y]     ==  this.tilemineable && 
                        this.mapfinal[x][y+1]   ==  this.tilesolid){
                        this.tilemap[x][y] = this.randomBag([44,45])//44 45

                    }

                }
            }
            // Gold ore vains corners
            for(var y=0;y<this.mmh;y+=1){
                for(var x=0;x<this.mmw;x+=1){
                    // corners right side  
                    if(  
                        this.mapBound(x+1,y)==true && this.mapBound(x,y-1)==true &&
                        this.mapfinal[x][y]     ==  this.tilemineable && 
                        this.mapfinal[x+1][y]   ==  this.tilesolid && 
                        this.mapfinal[x][y-1]   ==  this.tilesolid){
                        this.tilemap[x][y] = this.randomBag([48])                      
                    }
                   if(  
                        this.mapBound(x+1,y)==true && this.mapBound(x,y+1)==true &&
                        this.mapfinal[x][y]     ==  this.tilemineable && 
                        this.mapfinal[x+1][y]   ==  this.tilesolid && 
                        this.mapfinal[x][y+1]   ==  this.tilesolid){
                        this.tilemap[x][y] = this.randomBag([49])                      
                    }
                    // corners left side
                   if(  
                        this.mapBound(x-1,y)==true && this.mapBound(x,y-1)==true &&
                        this.mapfinal[x][y]     ==  this.tilemineable && 
                        this.mapfinal[x-1][y]   ==  this.tilesolid && 
                        this.mapfinal[x][y-1]   ==  this.tilesolid){
                        this.tilemap[x][y] = this.randomBag([46])                      
                    }
                   if(  
                        this.mapBound(x-1,y)==true && this.mapBound(x,y+1)==true &&
                        this.mapfinal[x][y]     ==  this.tilemineable && 
                        this.mapfinal[x-1][y]   ==  this.tilesolid && 
                        this.mapfinal[x][y+1]   ==  this.tilesolid){
                        this.tilemap[x][y] = this.randomBag([47])                      
                    }
                }
            }
            
            // dark areas
            for(var y=0;y<this.mmh;y+=1){
                for(var x=0;x<this.mmw;x+=1){

                    if(this.mapfinal[x][y]==this.tilesolid){
                        
                        /*
                        for(var i=-2;i<3;i++){
                        for(var j=-2;j<3;j++){
                            if(this.mapfinal[x+i][y+j]==this.tilesolid){
                                cnt+=1                                
                            }
                        }
                        }
                        //console.log(cnt)
                        if(cnt==25){
                            this.tilemap[x][y]=18
                            this.lightmap[x][y]+=1;
                        }
                        cnt=0;
                        for(var i=-3;i<4;i++){
                        for(var j=-3;j<4;j++){
                            if(this.mapfinal[x+i][y+j]==this.tilesolid){
                                cnt+=1                                
                            }
                        }
                        }
                        //console.log(cnt)
                        if(cnt==49){
                            this.lightmap[x][y]+=1;
                        }
                        */
                        for(var z=1;z<5;z++){
                            var cnt=0
                            var mx=0
                            for(var i=-z;i<=z;i++){
                            for(var j=-z;j<=z;j++){
                                mx++;
                            }}
                            for(var i=-z;i<=z;i++){
                            for(var j=-z;j<=z;j++){
                                if(this.mapBound(x+i,y+j) && this.mapfinal[x+i][y+j]==this.tilesolid){
                                    cnt+=1
                                                                    
                                }
                            }
                            }
                            //console.log(z*z)
                            if(cnt>=mx){
                                //console.log("aas")
                                //this.tilemap[x][y]=19//this.randomBag([20,21])//18
                                this.lightmap[x][y]+=.33
                                if(this.lightmap[x][y]>1)this.lightmap[x][y]=1
                            }
                        }
                    }

                }
            }

        }
       
        // return random of inputted array
        randomBag(a){
            return a[Math.floor(Math.random()*a.length)]
        }
        // stay within map bound 
        mapBound(x,y){
            if(x<0 || x>=this.mmw || y<0 || y>=this.mmh)return false
            return true
        }
        // Here we create the parts on the mapfinal that can be mined
        // by the player (like in minecraft/digger) tilemineable
        createfinalmineable(){
            // 3 high mineable mineshafts right to left
            for(var y1=15;y1<this.mmh-10;y1++){
                for(var x1=3;x1<this.mmw-3;x1++){
                    // Find suitable spot
                    if (this.mapfinal[x1][y1] != this.tilesolid) continue;
                    if (this.mapfinal[x1+1][y1] != this.tileempty) continue;
                    if (this.mapfinal[x1][y1+1] != this.tilesolid) continue;
                    if (this.mapfinal[x1][y1+2] != this.tilesolid) continue;
                    if (this.mapfinal[x1][y1+3] != this.tilesolid) continue;
                    if (this.mapfinal[x1+1][y1+4] != this.tilesolid) continue;
                    if (this.mapfinal[x1+1][y1+1] != this.tileempty) continue;
                    if (this.mapfinal[x1+1][y1+2] != this.tileempty) continue;
                    if (this.mapfinal[x1+1][y1+3] != this.tileempty) continue;
                    // See how far left we can go
                    var len=0;			
                    for(var x2=x1;x2>3;x2-=1){
                        if (this.mapfinal[x2][y1] != this.tilesolid)break;
                        if (this.mapfinal[x2][y1+1] != this.tilesolid)break;
                        if (this.mapfinal[x2][y1+2] != this.tilesolid)break;
                        if (this.mapfinal[x2][y1+3] != this.tilesolid)break;
                        if (this.mapfinal[x2][y1+4] != this.tilesolid)break;
                        len+=1;
                    }
                    // If we can go deep enough then prepare mineshaft
                    //console.log(len)
                    if(len<=10 || len>20)continue;
                    len = randomRange(7,len);
                    for(var x2=x1;x2>x1-(len-3);x2-=1){
                        for(var y2=y1+1;y2<y1+4;y2++){ 
                            
                            this.mapfinal[x2][y2] = this.tilemineable;
                        }
                    }
                }
            }
            //
            //
            // 3 high mineable mineshafts left to right
            for(var y1=15;y1<this.mmh-10;y1++){
                for(var x1=3;x1<this.mmw-3;x1++){
                    // Find suitable spot
                    if(this.mapfinal[x1][y1] != this.tilesolid)continue;
                    if(this.mapfinal[x1-1][y1] != this.tileempty)continue;
                    if(this.mapfinal[x1][y1+1] != this.tilesolid)continue;
                    if(this.mapfinal[x1][y1+2] != this.tilesolid)continue;
                    if(this.mapfinal[x1][y1+3] != this.tilesolid)continue;
                    if(this.mapfinal[x1-1][y1+4] != this.tilesolid)continue;
                    if(this.mapfinal[x1-1][y1+1] != this.tileempty)continue;
                    if(this.mapfinal[x1-1][y1+2] != this.tileempty)continue;
                    if(this.mapfinal[x1-1][y1+3] != this.tileempty)continue;
                    // See how far left we can go
                    var len=0;			
                    for(var x2=x1;x2<this.mmw-4;x2++){
                        if(this.mapfinal[x2][y1] != this.tilesolid)break;
                        if(this.mapfinal[x2][y1+1] != this.tilesolid)break;
                        if(this.mapfinal[x2][y1+2] != this.tilesolid)break;
                        if(this.mapfinal[x2][y1+3] != this.tilesolid)break;
                        if(this.mapfinal[x2][y1+4] != this.tilesolid)break;
                        len+=1
                    }
                    // If we can go deep enough then prepare mineshaft
                    if(len<=10)continue;
                    len = randomRange(7,len);
                    for(var x2=x1;x2<x1+(len-3);x2++){
                        for(var y2=y1+1;y2<y1+4;y2++){ 
                            this.mapfinal[x2][y2] = this.tilemineable;
                        }
                    }
                }
            }


        }


        finalizemap(){
            for(var y=1;y<this.mh-1;y++){
                for(var x=1;x<this.mw-1;x++){
                    if(this.map[x][y] == this.tileempty){
                        for(var y2=-1;y2<=1;y2++){
                            for(var x2=-1;x2<=1;x2++){
                                this.mapfinal[Math.floor((x*3)+x2)][Math.floor((y*3)+y2)] = this.tileempty;
                            }
                        }			
                    }
                }
            }
            // make ladders/vines
            for(var y=0;y<this.mh;y++){
                for(var x=0;x<this.mw;x++){
                    if(this.map[x][y] == 1){
                        if(x-1>=0 && this.map[x-1][y] == 0){
                            if(this.map[x+1][y] == 0){			
                                var y2=y;
                                while(this.map[x][y2] != 0){				
                                    this.mapladder[Math.floor((x*3))][Math.floor(y2*3)] = 1;
                                    this.mapladder[Math.floor((x*3))][Math.floor(y2*3-1)] = 1;
                                    this.mapladder[Math.floor((x*3))][Math.floor(y2*3+1)] = 1;				
                                    y2-=1;
                                }
                                y2=y;
                                while(this.map[x][y2] != 0){				
                                    this.mapladder[Math.floor((x*3))][Math.floor(y2*3)] = 1;
                                    this.mapladder[Math.floor((x*3))][Math.floor(y2*3-1)] = 1;
                                    this.mapladder[Math.floor((x*3))][Math.floor(y2*3+1)] = 1;
                                    y2+=1;
                                }
                            }
                        } 
                    }
                }
            }
            // make doors
            for(var i=0;i<this.mmw*this.mmh/2;i++){
                var x=randomRange(3,this.mmw-4);
                var y=randomRange(3,this.mmh-2);
                // door right side of tunnel
        //'		if(Math.rnd()<0){
                if(this.mapfinal[x][y] == 0){
                if(this.mapfinal[x+1][y] == 0){
                if(this.mapfinal[x-1][y] == 0){
                if(this.mapfinal[x-2][y] == 0){
                if(this.mapfinal[x-3][y] == 1){
                if(this.mapfinal[x][y+1] == 1){
                if(this.mapfinal[x][y+2] == 1){
                if(this.mapfinal[x][y+3] == 1){
                if(this.mapfinal[x][y+4] == 0){
                    this.mapfinal[x][y+1] = 1;
                    this.mapfinal[x][y+2] = 1;
                    this.mapfinal[x][y+3] = 1;
                    this.mapdoor[x][y+1 ] = 1;
                    this.mapdoor[x][y+2 ] = 1;
                    this.mapdoor[x][y+3 ] = 1;
                } 
                }
                } 
                } 
                }
                } 
                }
                }
                }
        //'		}
                // door left side of tunnel
                if(this.mapfinal[x-1][y-1] == 0){
                if(this.mapfinal[x][y] == 0){
                if(this.mapfinal[x-1][y] == 0){
                if(this.mapfinal[x+1][y] == 0){
                if(this.mapfinal[x+2][y] == 0){
                if(this.mapfinal[x+3][y] == 1){
                if(this.mapfinal[x][y+1] == 1){
                if(this.mapfinal[x][y+2] == 1){
                if(this.mapfinal[x][y+3] == 1){
                if(this.mapfinal[x][y+4] == 0){
                    this.mapfinal[x][y+1] = 1;
                    this.mapfinal[x][y+2] = 1;
                    this.mapfinal[x][y+3] = 1;
                    this.mapdoor[x][y+1 ] = 1;
                    this.mapdoor[x][y+2 ] = 1;
                    this.mapdoor[x][y+3 ] = 1;
                } 
                }
                } 
                } 
                } 
                }
                } 
                }
                }
                }

            }
        }
        
        makemap(){
            
            for(var y=1;y<6;y++){
                for(var x=1;x<this.mw-1;x++){
                    this.map[x][y] = 1;
                }
            }
            var minedownx=5+(Math.floor(Math.random()*this.mw)-15);
            for(var y=5;y<(this.mh/2)+10;y++){
                this.map[Math.floor(this.mw/2)][y] = 1;
            }
            for(var i=0;i<(this.mw*this.mh)*6;i++){
                var x=randomRange(2,this.mw-4);
                var y=randomRange(2,this.mh-4);
                if(this.map[x][y] == 1){					
                    var v=randomRange(0,2);
                    //Select v
                    if(v==0){
                        //    Case 0'go left or right										
                        if(this.map[x-1][y] == 0){

                            if(this.map[x-1][y] == 0){
                                if(this.map[x+1][y] == 0){										
                                    this.makeside(x,y,randomRange(0,2));
                                } 
                            }
                        }
                    }
                    if(v==1){
    					if(this.map[x][y-1]==0){
	    				    if(this.map[x][y+1]==0){
		    			        this.makevert(x,y,randomRange(0,2));
                            }
                        }
                    }
                }
            }
            this.widenhorizontal();
        }
        widenhorizontal(){
            for(var i=0;i<this.mw*this.mh/2;i++){
                var x=randomRange(2,this.mw-2);
                var y=randomRange(2,this.mh-2);
                if(this.map[x][y] == 1 && this.map[x][y-1] == 0 && this.map[x][y+1] == 0){				
                    var w=0;
                    var x2=x;
                    var exitloop=false;
                    while(exitloop == false){
                        if(this.map[x2][y] == 0) exitloop = true; 
                        if(this.map[x2][y-1] == 1) exitloop = true;
                        if(this.map[x2][y+1] == 1) exitloop = true;				
                        x2+=1;
                        w+=1;
                    }
                    //
                    
                    if(w-2>3){					
                        for(var x2=x;x2<=x+w-2;x2++){
                            this.map[x2][y-1] = 1;
                            this.map[x2][y+1] = 1;
                            if(x2>x+2 && w>6 && x2<(x+5)){
                                this.map[x2][y+2] = 1;
                            }
                        }
                    }
                }
            }
        }
        makevert(x,y,side){
            var l=randomRange(4,20);
            if(y<22)return;
            if(y>this.mh-22)return;
            if(side ==  0){//down		
                if(this.overlap(x-4,y+1,x+4,y+l+2) == false){
                    for(var y2=y;y2<=y+l;y2++){
                        this.map[x][y2] = 1;
                    }
                }
            }
            if(side ==  1){//up
                if(this.overlap(x-4,(y-l)-3,x+4,y-1) == false){
                    for(var y2=y-l;y2<=y;y2++){
                        this.map[x][y2] = 1;
                    }
                }
            }

        }

        makeside(x,y,side){		
            
            var l=randomRange(4,20);		
            if(x<22)return;
            if(x>this.mw-22)return;				
            if(side==0){// 'left			

                if(this.overlap((x-l)-2,y-5,x,y+5) == false){				
                    for(var x2=x-l;x2<x;x2++){
                        this.map[x2][y] = 1;
                    }
                }
            }
            if(side==1){// 'right		
                if(this.overlap(x+1,y-5,x+l+2,y+5) == false){								
                    for(var x2=x;x2<x+l;x2++){
                        this.map[x2][y] = 1;
                    }
                }			
            }	
        }
        overlap(x1,y1,x2,y2){
            //return rectsoverlap(x1,y1,x2,y2);
            for(var y=y1;y<y2;y++){
                for(var x=x1;x<x2;x++){
                    if(x>0 && x<this.mw && y>0 && y<this.mh){
                        if(this.map[x][y] == 1)return true;
                    }
                }
            }
            return false;
        }
        drawladder(){
            ctx2.save()
            ctx2.scale(.7,.7)
            ctx2.translate(screenwidth*.15,screenheight*.15)            						
            for(var y=0;y<this.mmh;y++){
                for(var x=0;x<this.mmw;x++){
                    //Select mapladder[x,y]				
                    if(this.mapladder[x][y]==0){
                        //'canvas.Color = Color.None
                        //'canvas.DrawRect(x*tw,y*th,tw,th)
                    }
                    if(this.mapladder[x][y]==1){	
                        //canvas.Color = New Color(0.4,0,0)
                        //canvas.DrawRect(x*tw,y*th,tw,th)
                        //'canvas.DrawRect(0,0,100,100)
                        //canvas.Color = New Color(0.7,0.7,0)
                        //canvas.DrawLine(x*tw,y*th,x*tw,y*th+th-2)
                        ctx2.fillStyle = 'rgb(80,0,0)';
                        ctx2.fillRect(x*this.tw,y*this.th,this.tw,this.th);
                        ctx2.fillStyle = 'rgb(160,160,0)';
                        drawLine(x*this.tw,y*this.th,x*this.tw,y*this.th+this.th-2,'rgb(160,160,0)');
                    }
                    //End Select			
                }
            }	
            ctx2.restore()
            ctx2.scale(1,1)	
        }

        updateladderimage(){				
        
            //canvas.BlendMode = BlendMode.Opaque
            //canvas.Clear(New Color(0,0,0,.5))
            for(var y=0;y<this.mmh;y++){// Until mmh
                for(var x=0;x<this.mmw;x++){
                    if(this.mapladder[x][y]==0){
                    }
                    if(this.mapladder[x][y]==1){
                        ctx.fillStyle = 'red';
                        ctx.globalAlpha = 0.5;
                        ctx.fillRect(x*this.tw,y*this.th,this.tw,this.th);
                        ctx.fillStyle = 'yellow';
                        drawLine(x*this.tw,y*this.th,x*this.tw,y*this.th+this.th-2);
                        ctx.globalAlpha = 1;
                    }
                    /*
                    Select mapladder[x,y]				
                        Case 0
                        canvas.Color = Color.None
                        canvas.DrawRect(x*tw,y*th,tw,th)
                        Case 1								
                        canvas.Color = Color.Red
                        canvas.Alpha = 0.5
                        canvas.DrawRect(x*tw,y*th,tw,th)
                        canvas.Color = Color.Yellow
                        canvas.DrawLine(x*tw,y*th,x*tw,y*th+th-2)
                    End Select
                    */
                }
            }
            //canvas.Flush()
        }	
        draw(){		
            for(var y=0;y<this.mmh;y++){
                for(var x=0;x<this.mmw;x++){
                    if(this.mapfinal[x][y]==this.tilesolid){
                        ctx.fillStyle = 'black';
                    }
                    if(this.mapfinal[x][y]==this.tileempty){
                        ctx.fillStyle = 'white';
                        ctx.fillRect(x*this.tw,y*this.th,this.tw,this.th);
                    }
                    if(this.mapfinal[x][y]==this.tileegg){
                        ctx.fillStyle = 'yellow';
                        ctx.fillRect(x*this.tw,y*this.th,this.tw,this.th);
                    }

                    //Select mapfinal[x,y]
                        //Case tilesolid
                        //canvas.Color = Color.Black
                        //Case tileempty
                        //canvas.Color = Color.White
                        //canvas.DrawRect(x*tw,y*th,tw,th)
                        //Case tileegg			
                       // canvas.Color = Color.Yellow
                        //canvas.DrawRect(x*tw,y*th,tw,th)
                    //End Select	
                }
            }		
        }
        updateimage(){
            		
         
            //canvas.BlendMode = BlendMode.Opaque	
            //canvas.Clear(Color.Black)
            //canvas.BlendMode = BlendMode.Opaque
            ctx2.fillStyle='black'
            ctx2.fillRect(0,0,screenwidth,screenheight)

            ctx2.save()
            ctx2.scale(.7,.7)
            ctx2.translate(screenwidth*.15,screenheight*.15)
            var sw1=-1
            var sw2=1
                        //console.log(this.mapfinal[this.mmw-1][0])

            for(var y=2;y<this.mmh;y++){
                for(var x=2;x<this.mmw;x++){
                    var a = this.mapfinal[x][y];
                    if(a==this.tileempty){
                        if(y>16){
                        ctx2.globalAlpha = 1;
                        ctx2.fillStyle = 'rgb(38,35,61)'//'rgb(50,20,5)';
                        ctx2.fillRect(x*this.tw,y*this.th,this.tw+1,this.th+1);
                        }
                    }
                    if(a==this.tilesolid && y>16){
                        ctx2.globalAlpha = 1;
                        //ctx2.fillStyle = 'brown';
                        if(sw1==-1 && sw2==-1){
                        ctx2.fillStyle = 'rgb(74,53,60)'
                        }else{
                        ctx2.fillStyle = 'rgb(114,90,81)'
                        ctx2.fillRect(x*this.tw,y*this.th,this.tw+1,this.th+1);
                        }
                    }
                    if(a==this.tileegg){
                        ctx2.globalAlpha = 0.8;
                        ctx2.fillStyle = 'yellow';
                        ctx2.fillRect(x*this.tw,y*this.th,this.tw+1,this.th+1);
                    }
                    if(a==this.tileturret){
                        ctx2.globalAlpha = 0.8;
                        ctx2.fillStyle = 'grey';
                        ctx2.fillRect(x*this.tw,y*this.th,this.tw+1,this.th+1);
                    }
                    if(a==this.tilemineable){
                        
                        ctx2.globalAlpha = 0.8;
                        ctx2.fillStyle = 'rgb(180,180,30)';
                        ctx2.fillRect(x*this.tw,y*this.th,this.tw,this.th);
                    }
                    sw1=-sw1
                }
                sw2=-sw2
            }
            ctx2.restore()
            ctx2.scale(1,1)

            var cornerSizeV = (screenheight) / 16
            var cornerSizeH = (screenwidth) / 16
            var top = 0
            var bottom = screenheight*.8
            var left = screenwidth*.1
            var right = screenwidth*.85
            ctx2.scale(1,1)
            ctx2.fillStyle = 'rgb(10,10,40)';
            //ctx2.globalAlpha = 0.5
            ctx2.beginPath();
            ctx2.moveTo(left+cornerSizeH,top+cornerSizeV);
            ctx2.lineTo(right-cornerSizeH*2,top+cornerSizeV);
            ctx2.lineTo(right-50,top+cornerSizeV*2)
            ctx2.lineTo(right-50,bottom-cornerSizeV)
            ctx2.lineTo(right-50-cornerSizeH,bottom)
            ctx2.lineTo(left+cornerSizeH,bottom)
            ctx2.lineTo(left,bottom-cornerSizeV)
            ctx2.lineTo(left,top+cornerSizeV*2)
            ctx2.closePath();
            ctx2.globalAlpha = 0.3
            ctx2.fill();      
            ctx2.globalAlpha = 1    
            ctx2.strokeStyle = 'rgb(211,211,0)'
            ctx2.lineWidth = 6
            ctx2.stroke()
            ctx2.strokeStyle = 'rgb(255,255,255)'
            ctx2.lineWidth = 1
            ctx2.stroke()   


            //canvas.Flush()
            //ctx=c.getContext("2d");{
        } 
        mapmineablecollide(x,y,w,h,remove,kind){
            
            var mmw=mymap.mmw;
            var mmh=mymap.mmh;
            var lefttopx		=Math.floor(((x)/tilewidth));
            var lefttopy		=Math.floor(((y)/tileheight));
            var righttopx		=Math.floor(((x+w)/tilewidth));
            var righttopy		=Math.floor(((y)/tileheight));
            var leftbottomx 	=Math.floor(((x)/tilewidth));
            var leftbottomy 	=Math.floor(((y+h)/tileheight));
            var rightbottomx	=Math.floor(((x+w)/tilewidth));												
            var rightbottomy	=Math.floor(((y+h)/tileheight));
            if(lefttopx < 0 || lefttopx >= mmw)return true;
            if(lefttopy < 0 || lefttopy >= mmh)return true;
            if(righttopx < 0 || righttopx >= mmw)return true;
            if(righttopy < 0 || righttopy >= mmh)return true;
            if(leftbottomx < 0 || leftbottomx >= mmw)return true;
            if(leftbottomy < 0 || leftbottomy >= mmh)return true;
            if(rightbottomx < 0 || rightbottomx >= mmw)return true;
            if(rightbottomy < 0 || rightbottomy >= mmh)return true;
            
            if(mymap.mapfinal[lefttopx][lefttopy] == mymap.tilemineable){
                myflashingeffect.push(new flash(lefttopx*tilewidth,lefttopy*tileheight)) 

                if(remove==true){
                    this.removemineable(lefttopx,lefttopy,kind);
                }
                return true;
            }
            if(mymap.mapfinal[righttopx][righttopy] == mymap.tilemineable){ 
                myflashingeffect.push(new flash(righttopx*tilewidth,righttopy*tileheight))
                
                if(remove==true){
                   this.removemineable(righttopx,righttopy,kind);
                }
                return true;
            }
            if(mymap.mapfinal[leftbottomx][leftbottomy] == mymap.tilemineable){ 
                myflashingeffect.push(new flash(leftbottomx*tilewidth,leftbottomy*tileheight))
                
                if(remove==true){
                    this.removemineable(leftbottomx,leftbottomy,kind);
                }
                return true;
            }
            if(mymap.mapfinal[rightbottomx][rightbottomy] == mymap.tilemineable){
                myflashingeffect.push(new flash(rightbottomx*tilewidth,rightbottomy*tileheight))
                
                if(remove==true){
                    this.removemineable(rightbottomx,rightbottomy,kind);
                }
                return true;						
            }
            return false;
        }

        // Every now and then remove mineable tile
        // and add item
        //
        removemineable(x,y,kind){
            var chance=10;
            if(kind=="gun")chance=50; 
            if(kind=="frag")chance = 10;
            if(randomRange(0,chance) < 2){
                mymap.mapfinal[x][y] = mymap.tileempty;
                mymap.tilemap[x][y] = mymap.randomBag([0,1,2])
                myitem.push(
                    new item(
                        (x*tilewidth)+tilewidth/2,(y*tileheight)+tileheight/2,"Gold"
                        )
                );                
                //myitem.Add(New item((x*tilewidth)+tilewidth/2,(y*tileheight)+tileheight/2,"gold"))
            }
        }
            
        tilecollide(x,y,w,h,tile){
            var lefttopx		=((x)/tilewidth);
            var lefttopy		=((y)/tileheight);
            var righttopx		=((x+w)/tilewidth);
            var righttopy		=((y)/tileheight);
            var leftbottomx 	=((x)/tilewidth);
            var leftbottomy 	=((y+h)/tileheight);
            var rightbottomx	=((x+w)/tilewidth);												
            var rightbottomy	=((y+h)/tileheight);
            if(lefttopx < 0 || lefttopx >= this.mmw)return  false;
            if(lefttopy < 0 || lefttopy >= this.mmh)return  false;
            if(righttopx < 0 || righttopx >= this.mmw)return  false;
            if(righttopy < 0 || righttopy >= this.mmh)return  false;
            if(leftbottomx < 0 || leftbottomx >= this.mmw)return  false;
            if(leftbottomy < 0 || leftbottomy >= this.mmh)return  false;
            if(rightbottomx < 0 || rightbottomx >= this.mmw)return  false;
            if(rightbottomy < 0 || rightbottomy >= this.mmh)return  false;
            
            if(this.mapfinal[lefttopx][lefttopy] == tile)return  true;
            if(this.mapfinal[righttopx][righttopy] == tile)return  true;
            if(this.mapfinal[leftbottomx][leftbottomy] == tile)return  true;
            if(this.mapfinal[rightbottomx][rightbottomy] == tile)return  true;						
            return false;
        }
        mapcollide(x,y,w,h){
            //console.log(x+","+y+","+w+","+h);
            var lefttopx		=Math.floor(((x)/tilewidth));
            var lefttopy		=Math.floor(((y)/tileheight));
            var righttopx		=Math.floor(((x+w)/tilewidth));
            var righttopy		=Math.floor(((y)/tileheight));
            var leftbottomx 	=Math.floor(((x)/tilewidth));
            var leftbottomy 	=Math.floor(((y+h)/tileheight));
            var rightbottomx	=Math.floor(((x+w)/tilewidth));												
            var rightbottomy	=Math.floor(((y+h)/tileheight));
            if(lefttopx < 0 || lefttopx >= this.mmw)return true;
            if(lefttopy < 0 || lefttopy >= this.mmh)return true;
            if(righttopx < 0 || righttopx >= this.mmw)return true;
            if(righttopy < 0 || righttopy >= this.mmh)return true;
            if(leftbottomx < 0 || leftbottomx >= this.mmw)return true;
            if(leftbottomy < 0 || leftbottomy >= this.mmh)return true;
            if(rightbottomx < 0 || rightbottomx >= this.mmw)return true;
            if(rightbottomy < 0 || rightbottomy >= this.mmh)return true;
            
            
            if(this.mapfinal[lefttopx][lefttopy] != mymap.tileempty) return  true;
            if(this.mapfinal[righttopx][righttopy] != mymap.tileempty) return  true;
            if(this.mapfinal[leftbottomx][leftbottomy] != mymap.tileempty) return  true;
            if(this.mapfinal[rightbottomx][rightbottomy] != mymap.tileempty) return  true;						
            return false;
        }
        //Collide with solid and mineable
        mapcollide2(x,y,w,h){
            
            var lefttopx		=Math.floor(((x)/tilewidth));
            var lefttopy		=Math.floor(((y)/tileheight));
            var righttopx		=Math.floor(((x+w)/tilewidth));
            var righttopy		=Math.floor(((y)/tileheight));
            var leftbottomx 	=Math.floor(((x)/tilewidth));
            var leftbottomy 	=Math.floor(((y+h)/tileheight));
            var rightbottomx	=Math.floor(((x+w)/tilewidth));												
            var rightbottomy	=Math.floor(((y+h)/tileheight));
            if(lefttopx < 0 || lefttopx >= this.mmw)return true;
            if(lefttopy < 0 || lefttopy >= this.mmh)return true;
            if(righttopx < 0 || righttopx >= this.mmw)return true;
            if(righttopy < 0 || righttopy >= this.mmh)return true;
            if(leftbottomx < 0 || leftbottomx >= this.mmw)return true;
            if(leftbottomy < 0 || leftbottomy >= this.mmh)return true;
            if(rightbottomx < 0 || rightbottomx >= this.mmw)return true;
            if(rightbottomy < 0 || rightbottomy >= this.mmh)return true;

            if(this.mapfinal[lefttopx][lefttopy] == mymap.tilesolid)return true;
            if(this.mapfinal[righttopx][righttopy] == mymap.tilesolid) return  true;
            if(this.mapfinal[leftbottomx][leftbottomy] == mymap.tilesolid) return  true;
            if(this.mapfinal[rightbottomx][rightbottomy] == mymap.tilesolid) return  true;						

            if(this.mapfinal[lefttopx][lefttopy] == mymap.tilemineable) return  true;
            if(this.mapfinal[righttopx][righttopy] == mymap.tilemineable) return  true;
            if(this.mapfinal[leftbottomx][leftbottomy] == mymap.tilemineable) return  true;
            if(this.mapfinal[rightbottomx][rightbottomy] == mymap.tilemineable) return  true;						

            return false;
        }

    }

    c.addEventListener("touchend", touchHandler);
    c.addEventListener("touchstart", touchHandler);
 

    var mymenuselect = new menuselect()
    
    var myegg = [];
    var mymap = new map(screenwidth-48,screenheight-48,mapwidth,mapheight);
    //var myc=new player();
    var myplayer=new player();
    var mygrowslime = new growslime();
    var mybullet = [];
    var mygrenade = [];
    var myfrag = [];
    var myitem = [];
    var myflyingmonster = [];
    var mywalkingmonster = [];    
    var myturret = [];
    var mynumberfall = [];
    var mytentacle = [];
    var mytownperson = [];
    var mylaserwall = [];
    var myflashingeffect = [];
    var mybuilding = []
    var buildmap = []
    
    //var stp = 296
    //for(var x=0;x<screenwidth;x+=stp){
    //    mybuilding.push(new building(0,0,2,stp/6,stp/4,randomRange(0,2)))
    //}
    
    //
    offscreenCanvas.width=window.innerWidth-32;
    offscreenCanvas.height=window.innerHeight-32;
    touchAreaDownX = []
    touchAreaDownY = []
    touchAreaWidth = []
    touchAreaHeight = []
    touchControlsLeft(true)
    touchControlsRight(true)

    //
    gameloop=setInterval(doGameLoop2,15);
    //
    function doGameLoop2(){
        myCanvas.height = window.innerHeight-32;
        myCanvas.width = window.innerWidth-32;
        //tw = Math.floor(myCanvas.width,tmap[0].length); 	
        //th = Math.floor(myCanvas.height,tmap.length);
        ctx.clearRect(0,0,c.width,c.height);
        ctx.fillStyle="rgb(0,0,0)";
        ctx.fillRect(0,0,c.width,c.height);


        if(gamestate=="select"){
            
            mymenuselect.update()
            mymenuselect.drawmap()
            mymenuselect.draw()
            mymenuselect.draw()   
            ctx.drawImage(offscreenCanvas,0,0)
            ctx.fillStyle="white"
            ctx.fillText("(Touch the screen to activate touch screen interface.)",0,35)
            touchControlsLeft(false)
            touchControlsRight(false)
            //ctx.globalAlpha = 1
            //for(var i=0;i<mybuilding.length;i+=1){
            //    mybuilding[i].draw(ctx,0,0)
            //}
            // Set to full screen or windowed mode
            if(setToggleFullScreenMode == true){
                setToggleFullScreenMode = false
                toggleFullScreen()
            }
        }
        if(gamestate=="setup"){
            addonce = 1;
            myplayer=new player();
            myegg = []
            mymap = new map(screenwidth-48,screenheight-48,mapwidth,mapheight);
    var stp = 400
    for(var x=0;x<mapwidth*tilewidth;x+=stp){
        if(distanceM(x,0,(mapwidth*tilewidth)/2,0)>100){
        mybuilding.push(new building(0,0,randomRange(1,4),tilewidth*3,tileheight*2,randomRange(0,2)))
        buildmap.push(x)
        }
    }

            mymap.addAllEggsFromMap()
            mybullet = [];
            mygrenade = [];
            myfrag = [];
            myitem = [];
            myflyingmonster = [];
            mywalkingmonster = [];    
            //var myturret = [];
            mynumberfall = [];
            mytentacle = [];
            mytownperson = [];
            mylaserwall = [];
            mygrowslime = new growslime();
            //'
            //' Create the towns people
            //'
            
            for(var i=0;i<mapwidth/40;i++){
                mytownperson.push(
                    new townperson(
                        randomRange(3,mapwidth/2-5),
                        16) 
                );
                mytownperson.push(
                    new townperson(
                        randomRange(mapwidth/2+5,mapwidth-5),
                        16)
                );
        
                //mytownperson.Add(New townperson(Rnd(3,mapwidth/2-5),16))
                //mytownperson.Add(New townperson(Rnd(mapwidth/2+5,mapwidth-5),16))
            }
            myturret = [];
            //
            // add turrets
            myturret.push(
                new turret() 
            );
            myturret.push(
                new turret() 
            );

            for(var i=0;i<10;i++){
                //myegg.push(new egg(64-i,16))
            }
            if(developmode)myplayer.setPositionNearSlimeMonster()

            gamestate = "play"
        }
        
        if(gamestate=="play"){
               
            // Set to full screen or windowed mode
            if(setToggleFullScreenMode == true){
                setToggleFullScreenMode = false
                toggleFullScreen()
            }            
            //  UPDATES
            //
            // grow slime monster
            //for(var i=0;i<5;i+=1){
            mygrowslime.update("slow")
            //}
            //update the towns people
            for(i=0;i<mytownperson.length;i++){
                mytownperson[i].update();
            }

            // update the eggs
            if(myegg.length>0){
                //Update the eggs
                for(var i=0;i<myegg.length;i++){
                    myegg[i].update();
                
                }
                // remove eggs from list
                for(var i=myegg.length-1;i>=0;i-=1){
                    if(myegg[i].deleteme == true){
                        myegg.splice(i, 1);
                    }
                }		
            }

            // update the laserwall
            if(mylaserwall.length>0){
                //Update the laserwall
                for(var i=0;i<mylaserwall.length;i++){
                    mylaserwall[i].update();
                
                }
                // remove laserwall from list
                for(var i=mylaserwall.length-1;i>=0;i-=1){
                    if(mylaserwall[i].deleteme == true){
                        mylaserwall.splice(i, 1);
                    }
                }		
            }
            // update the tentacles
            if(mytentacle.length>0){
                //Update the tentacles
                for(var i=0;i<mytentacle.length;i++){
                    mytentacle[i].update();
                
                }
                // remove tentacle from list
                for(var i=mytentacle.length-1;i>=0;i-=1){
                    if(mytentacle[i].deleteme == true){
                        mytentacle.splice(i, 1);
                    }
                }		
            }
        
            // update the bullets
            if(mybullet.length>0){
                //Update the bullets
                for(var i=0;i<mybullet.length;i++){
                    mybullet[i].update();
                
                }
                // remove bullet from list
                for(var i=mybullet.length-1;i>=0;i-=1){
                    if(mybullet[i].deleteme == true){
                        mybullet.splice(i, 1);
                    }
                }		
            }
            // Update the grenades
            if(mygrenade.length>0){
                
                //Update the grenades
                for(var i=0;i<mygrenade.length;i++){
                    
                    mygrenade[i].update();
                    
                }
                // remove grenade from list
                for(var i=mygrenade.length-1;i>=0;i-=1){
                    if(mygrenade[i].deleteme == true){
                        mygrenade.splice(i, 1);
                    }
                }		
            }
            // Update the frag
            if(myfrag.length>0){            
                //Update the frags
                for(var i=0;i<myfrag.length;i++){                
                    myfrag[i].update();                
                }
                // remove frag from list
                for(var i=myfrag.length-1;i>=0;i-=1){
                    if(myfrag[i].deleteme == true){
                        myfrag.splice(i, 1);
                    }
                }		
            }
            // Update the items
            if(myitem.length>0){            
                //Update the items
                for(var i=0;i<myitem.length;i++){                
                    myitem[i].update();                
                }
                // remove item from list
                for(var i=myitem.length-1;i>=0;i-=1){
                    if(myitem[i].deleteme == true){
                        myitem.splice(i, 1);
                    }
                }
            }
            // Update the flying monster
            if(myflyingmonster.length>0){            
                //Update the flying monster
                for(var i=0;i<myflyingmonster.length;i++){ 
                    for(var j=0;j<1;j++){               
                        myflyingmonster[i].update();
                    }              
                }
                // remove flying monster from list
                for(var i=myflyingmonster.length-1;i>=0;i-=1){
                    if(myflyingmonster[i].deleteme == true){
                        myflyingmonster.splice(i, 1);
                    }
                }
            }
            // Update the walking monster
            if(mywalkingmonster.length>0){            
                //Update the walking monster
                for(var i=0;i<mywalkingmonster.length;i++){ 
                    for(var j=0;j<1;j++){               
                        mywalkingmonster[i].update();
                    }              
                }
                // remove walking monster from list
                for(var i=mywalkingmonster.length-1;i>=0;i-=1){
                    if(mywalkingmonster[i].deleteme == true){
                        mywalkingmonster.splice(i, 1);
                    }
                }
            }
            // Update the falling numbers
            if(mynumberfall.length>0){            
                //Update the numbers
                for(var i=0;i<mynumberfall.length;i++){ 
                    for(var j=0;j<1;j++){               
                        mynumberfall[i].update();
                    }              
                }
                // remove falling numbers
                for(var i=mynumberfall.length-1;i>=0;i-=1){
                    if(mynumberfall[i].deleteme == true){
                        mynumberfall.splice(i, 1);
                    }
                }
            }
            // Update the flashing effect
            if(myflashingeffect.length>0){            
                //Update the numbers
                for(var i=0;i<myflashingeffect.length;i++){ 
                    for(var j=0;j<1;j++){               
                        myflashingeffect[i].update();
                    }              
                }
                // remove flashing effect 
                for(var i=myflashingeffect.length-1;i>=0;i-=1){
                    if(myflashingeffect[i].deleteme == true){
                        myflashingeffect.splice(i, 1);
                    }
                }
            }
            // Update the turret
            if(myturret.length>0){            
                //Update the turret
                for(var i=0;i<myturret.length;i++){ 
                    for(var j=0;j<=1;j++){               
                        myturret[i].update();
                    }              
                }
            }

            //if(myflyingmonster.length<maxflyingmonsters){
            //for(var i=0;i<=10;i++){
            //    addflyingmonster();
            //    addwalkingmonster();
            //}
            //}

            //mymap.draw();
            if(Controller.MiniMap==false){
                var tp=false;
                //If Keyboard.KeyDown(Key.LeftControl) 
                //	myplayer.userscrollmap()
                //	tp=True
                //}
                if(tp==false){
                    myplayer.updateplayercontrols()
                }

                //canvas.Clear(Color.Black)
                myplayer.draw()
                // Draw the touch screen buttons
                touchControlsLeft(false)
                
                touchControlsRight(false)

                //ctx.save()
                //ctx.scale(2,.7);    
                //ctx.globalAlpha = 0.5;       
                //ctx.fillStyle = 'black';
                //ctx.fillRect(0,0,360,38);
                //ctx.fillStyle = 'white';               
                //ctx.fillText("Press 1(new level) or Home(selection). Left shift(map view) I(Inventory)",0,15);
                //ctx.fillText("Cursors(move), z(shotgun), x(grenade), c(mine) space(jump) v(laserwall)..",0,30);
                //ctx.fillText("",320,15);//debug
                //ctx.scale(1,1);
                //ctx.restore()

                //
                // Set the scale - and smaller if the height is <500
                var msc = 1.3
                if(screenheight<500)msc/=1.6
                ctx.scale(msc,msc)//1.3,1.3
                    ctx.globalAlpha = 1
                    ctx.fillStyle = 'black'
                    ctx.fillRect(0,0,screenwidth/1.7,68)
                    ctx.globalAlpha = 1
                    ctx.fillStyle = 'rgb(160,160,160)'
                    ctx.fillRect(0,0,screenwidth/1.7,3)
                    ctx.fillRect(0,62,screenwidth/1.7,3)
                ctx.fillStyle = 'white'
                var barWidth = screenwidth / 10
                for(var i=0;i<6;i+=1){
                    //ctx.fillText(myplayer.playeritemnames[i],(i*120)+40,32)
                    ctx.fillStyle = 'rgb(20,10,40)'
                    ctx.fillRect(i*barWidth,9,barWidth/1.6,16)
                    ctx.fillStyle = 'white'
                    ctx.fillText(myplayer.playeritem[i][1],i*barWidth+6,20)
                    ctx.drawImage(mediumIconImage,tileAtlasIndex[i*2].x,tileAtlasIndex[i*2].y,
                                    tileImageCellSize*2,tileImageCellSize*2,
                                    (i*barWidth)+barWidth/2.4,0,
                                    tilewidth,tileheight
                                    )
                }
                for(var i=6;i<myplayer.playeritemnames.length;i+=1){
                    //ctx.fillText(myplayer.playeritemnames[i],((i-6)*120)+40,45)
                    ctx.fillStyle = 'rgb(20,10,40)'
                    ctx.fillRect((i-6)*barWidth,40,barWidth/1.6,16)
                    ctx.fillStyle = 'white'
                    ctx.fillText(myplayer.playeritem[i][1],((i-6)*barWidth)+6,50)
                    ctx.drawImage(mediumIconImage,tileAtlasIndex[(i*2)].x,tileAtlasIndex[(i*2)].y,
                                    tileImageCellSize*2,tileImageCellSize*2,
                                    ((i-6)*barWidth)+barWidth/2.4,32,
                                    tilewidth,tileheight
                                    )

                }

                ctx.globalAlpha = 1;

                //ctx.fillText(myflyingmonster[0].state+"-"+myflyingmonster[0].substate,320,30);//debug
            }
            //ctx.drawImage(tileImage,0,0,32,32,0,0,32,32);
            //drawTile(0,0,52)
            if(Controller.MiniMap==true){
                //offscreenCanvas.width=window.innerWidth-32;
                //offscreenCanvas.height=window.innerHeight-32;
                if(Math.random()<.1){
                    //ctx2.fillStyle = 'black'
                    //ctx.fillRect(0,0,ctx2.width,ctx2.height)
                    mymap.updateimage();    
                    mymap.drawladder();
                    mygrowslime.drawmap();

                    ctx2.save()
                    ctx2.scale(.7,.7)
                    ctx2.translate(screenwidth*.15,screenheight*.15)
                    
                    
                    var x1=myplayer.mcx*mymap.tw
                    var y1=myplayer.mcy*mymap.th
                    //ctx2.beginPath();
                    //ctx2.arc(x1+((mymap.tw*myplayer.maptileswidth)/2),y1+((mymap.tw*myplayer.maptileswidth)/6),(mymap.tw*myplayer.maptileswidth)/3, 0, 2 * Math.PI);
                    //ctx2.fill();
                    ctx2.globalAlpha = 0.25
                    ctx2.fillStyle = 'rgb(255,255,255)'
                    ctx2.fillRect(x1,y1,mymap.tw*myplayer.maptileswidth,mymap.th*myplayer.maptilesheight)
                    ctx2.globalAlpha = 1
                    ctx2.strokeStyle = 'rgb(255,255,255)'
                    ctx2.rect(x1,y1,mymap.tw*myplayer.maptileswidth,mymap.th*myplayer.maptilesheight)
                    ctx2.stroke()
                    ctx2.restore()
                    ctx2.scale(1,1)                
                }

                ctx2.globalAlpha=1;
                //ctx2.fillStyle="#FFFF00";
                //ctx2.fillRect(0,0,offscreenCanvas.width,offscreenCanvas.height);

                ctx.drawImage(offscreenCanvas,0,0);
                    ctx.save()
                    ctx.scale(.7,.7)
                    ctx.translate(screenwidth*.15,screenheight*.15)

                for(var i=0;i<myflyingmonster.length;i++){
                    myflyingmonster[i].draw();
                }
                for(var i=0;i<mywalkingmonster.length;i++){
                    mywalkingmonster[i].draw();
                } 
                ctx.restore()
                ctx.scale(1,1)
            }
        }
    }
   




    function rectmapcollide(x,y,w,h,offsetx,offsety){

        var cx=Math.floor((x-camx)/tw);
        var cy=Math.floor((y-camy)/th);

        for(var y2=cy-1;y2<cy+3;y2++){
        for(var x2=cx-1;x2<cx+3;x2++){	
            if(x2>=0 && x2<tmap[0].length && y2>=0 && y2<tmap.length){
                if(tmap[y2][x2] == 1){
                    var x3 = ((x2)*tw)+camx;
                    var y3 = ((y2)*th)+camy;
                    if(rectsoverlap(x+offsetx,y+offsety,w,h,x3,y3,tw,th)==true){
                        return true;
                    }
                }
            }
        }
        }
        return false;
    }

    function rectsoverlap(r1x1,r1y1,r1w,r1h,r2x1,r2y1,r2w,r2h){
        var r1x2 = r1x1+r1w;
        var r1y2 = r1y1+r1h;
        var r2x2 = r2x1+r2w;
        var r2y2 = r2y1+r2h;
        
        return (r1x1 < r2x2 && r1x2 > r2x1 && r1y1 < r2y2 && r1y2 > r2y1);

    }
    function create2DArray(rows,columns) {
        //var x = new Array(rows);
        //for (var i = 0; i < rows; i++) {
        //    x[i] = new Array(columns);
        //}
        //return x;
	    var x = [];
	    for(var i=0;i<rows;i++){
		    x[i] = new Array();
		    for(var j=0;j<columns;j++){
			    x[i][j]=0;
		    }
	    }
        return x;
    }

    function controllerconnected(evt){
    }

    // keyboard key down events
    function kd(evt){

        if(evt.keyCode==37){//cursor left
            Controller.Left = true;
        }
        if(evt.keyCode==39){//cursor right
            Controller.Right = true;
        }
        if(evt.keyCode==38){//cursor up
            Controller.Up = true;
        }
        if(evt.keyCode==40){//cursor down
            Controller.Down = true;
        }
        if(evt.keyCode==90){ // z
            Controller.ShotGun = true;
        }
        if(evt.keyCode==88){ //x
            Controller.Grenade = true;
        }
        //
        if(evt.keyCode==67){ //c
            //Controller.LaserWall = true;
        }
        //86
        if(evt.keyCode==86){ //v
            Controller.Mine = true;
        }
        if(evt.keyCode==32){ //space
            Controller.Jump = true;
        }
        if(evt.keyCode==16){ //left shift
            Controller.MiniMap = true;
        }
    }
    //
    // Keyboard events Key Up
    function ku(evt){
        if(evt.keyCode==37){
            Controller.Left = false;
        }
        if(evt.keyCode==39){
            Controller.Right = false;
        }
        if(evt.keyCode==38){
            Controller.Up = false;
        }
        if(evt.keyCode==40){
            Controller.Down = false;
        }
        if(evt.keyCode==90){ // z
            Controller.ShotGun = false;
        }
        if(evt.keyCode==88){ //x
            Controller.Grenade = false;
        }
        // Only trigger once..
        if(evt.keyCode==67){ //c
            Controller.LaserWall = true;
        }
        if(evt.keyCode==86){ //v
            Controller.Mine = false;
        }
        if(evt.keyCode==32){ //space
            Controller.Jump = false;
        }
        if(evt.keyCode==16){ //left shift
            Controller.MiniMap = false;
        }
    }
    //
    // This function adds a walking monster to the game
    //
    function addwalkingmonster(){ //hatch
        return
        var cnt = mywalkingmonster.length
        var cnt2 = myflyingmonster.length

        
        // and still some egg laying monsters left
        // If there are not to many walking monsters
        if(cnt<maxwalkingmonsters && cnt2>0){
            //DebugLog (mapwidth+mapheight)/10
            for(var i=0;i<(mapwidth+mapheight)/10;i+=1){
                if(Math.random()< egghatchspeed){
                    var x=randomRange(0,mapwidth)
                    var y=randomRange(0,mapheight)
                    if(mymap.mapfinal[x][y] == mymap.tileegg){
                        // If there are no walking monsters nearby
                        var makemonster=true
                        for(var ii=0;ii<mywalkingmonster.length;ii+=1){
                            if(distanceM(x,y,mywalkingmonster[ii].x,mywalkingmonster[ii].y) < 6)makemonster = false
                        }					
                        if(makemonster == true){
                            mymap.mapfinal[x][y] = mymap.tileempty
                            mywalkingmonster.push(
                                new walkingmonster(
                                x,y    
                                )
                            );
                            //mywalkingmonster.AddLast(New walkingmonster(x,y))
                            //mymap.updateimage(mymap.mapcanvas)
                        }
                    }
                }
            }
        }
    }
    //
    //This function adds a flying monster to the game
    //
    function addflyingmonster(){// 'hatch
        return
        var cnt=myflyingmonster.length;
        //for(var i=0;i<myflyingmonster.length;i++){
        //    cnt+=1
        //}
        if(cnt<maxflyingmonsters){
            //'DebugLog (mapwidth+mapheight)/10
            for(var i=0;i<(mapwidth+mapheight)/10;i++){
                if(Math.random() < egghatchspeed){
                    var x=randomRange(0,mapwidth);
                    var y=randomRange(0,mapheight);
                    if(mymap.mapfinal[x][y] == mymap.tileegg){
                        mymap.mapfinal[x][y] = mymap.tileempty
                        myflyingmonster.push(
                                new theflyingmonster(
                                x,y    
                                )
                            );

                        //console.log("monster added "+x+ ","+y)
                        //myflyingmonster.AddLast(New theflyingmonster(x,y))
                        //mymap.updateimage(mymap.mapcanvas)
                    }
                }
            }
        }
    }

    function drawLine(x1,y1,x2,y2,stroke = 'black', width = 1,c = ctx) {
        if (stroke) {
            c.strokeStyle = stroke;
        }

        if (width) {
            c.lineWidth = width;
        }

        c.beginPath();
        c.moveTo(x1,y1);
        c.lineTo(x2,y2);
        c.stroke();
    }
    function randomRange(min=0, max=1) {
        return Math.floor(Math.random() * (max - min) + min);
    }
    function randomRangeFloat(min=0, max=1) {
        return (Math.random() * (max - min) + min);
    }

    // Not floored.
    function getangle(x1,y1,x2,y2){
        return Math.atan2(y2-y1, x2-x1);
    }  	     
    // not floored - Manhattan distance
    function distanceM(x1,y1,x2,y2){
        return Math.abs(x2-x1)+Math.abs(y2-y1);
    }	
    //
    //
    // sprite - Draw a sprite from the sprite atlas
    function drawSprite(x,y,sprite,flipH=1,flipV=1){
        if(flipH==-1){
        ctx.save(); // Save the current state
        ctx.scale(-1, 1); // Set scale to flip the image    
        ctx.drawImage(spriteImage,tileAtlasIndex[sprite].x,tileAtlasIndex[sprite].y, tileImageCellSize , tileImageCellSize,
                        -x-tilewidth,y,tilewidth,tileheight);
        ctx.restore();
        }else{
        ctx.drawImage(spriteImage,tileAtlasIndex[sprite].x,tileAtlasIndex[sprite].y, tileImageCellSize , tileImageCellSize,
                        x,y,tilewidth,tileheight);
        }
    }
    //
    //
    // tile - Draw a tile from the level tile(s) atlas
    function drawTile(x,y,tile){
        ctx.drawImage(tileImage,tileAtlasIndex[tile].x,tileAtlasIndex[tile].y,tileImageCellSize,tileImageCellSize,
                        x,y,tilewidth,tileheight);
    }
    //
    // Create a list of the cell coordinates in the tile atlas image. (optimize)
    //
    function bufferTileAtlas(){
        tileAtlasIndex = []
        var tile = 0
        for(var j=0;j<(tileImageHeight/tileImageCellSize);j+=1){
            for(var i=0;i<(tileImageWidth/tileImageCellSize);i+=1){            
                var row = Math.floor(tile % maxRows)
                var column = Math.floor(tile / maxRows)                
                tileAtlasIndex.push({x:Math.floor(row*tileImageCellSize),y:Math.floor(column*tileImageCellSize)})
                tile+=1;
            }
        }
    }
    function touchControlsRight(setup=true){
        var tControlIconIndex = [1,2,0,0,3,0,4,0,5,5,2,3,4,5]
        
        if(setup==false){
            ctx.fillStyle = 'grey'
            //ctx.globalAlpha = 0.78//.45
            ctx.fillStyle = 'grey'
            //ctx.globalAlpha = 0.78//.45
            if(touchControlVisible==false)return
            ctx.globalAlpha = 0.8
            ctx.fillStyle = 'black'
            ctx.fillRect(   touchControlsRightX-touchButtonWidth-6,
                            touchControlsRightY-touchButtonHeight-6,
                            touchButtonWidth*3+6,(touchButtonHeight*3+12))
            ctx.globalAlpha = 1
            ctx.fillStyle = 'rgb(160,160,160)'
            ctx.fillRect(   touchControlsRightX-touchButtonWidth-6,
                            touchControlsRightY-touchButtonHeight-6,
                            touchButtonWidth*3+6,3)
            ctx.fillRect(   touchControlsRightX-touchButtonWidth-6,
                            touchControlsRightY-touchButtonHeight+(touchButtonHeight*3),
                            touchButtonWidth*3+6,3)

        } 
        var cnt=0
        for(var y=-1;y<=1;y+=1){
            for(var x=-1;x<=1;x+=1){

                if(setup==false){
                    if(touchControlVisible==false)return
                    ctx.fillRect(   touchControlsRightX+(x*(touchButtonWidth)),touchControlsRightY+(y*(touchButtonHeight)),
                                    touchButtonWidth*.9,touchButtonHeight*.9)
                    ctx.drawImage(
                        iconImage,
                        tileAtlasIndex[tControlIconIndex[cnt]].x,
                        tileAtlasIndex[tControlIconIndex[cnt]].y,
                        tileImageCellSize , tileImageCellSize,
                        touchControlsRightX+(x*(touchButtonWidth))+(touchButtonWidth/2-tilewidth/2),
                        touchControlsRightY+(y*(touchButtonHeight))+(touchButtonHeight/2-tileheight/2),
                        tilewidth,tileheight
                        )                                    
                }else{
                    touchAreaDownX.push((touchControlsRightX+(x*(touchButtonWidth))))
                    touchAreaDownY.push((touchControlsRightY+(y*(touchButtonHeight))))
                    touchAreaWidth.push(touchButtonWidth)
                    touchAreaHeight.push(touchButtonHeight)                                    
                }
                cnt+=1
            }
        }
        if(setup==false)ctx.globalAlpha = 1
    }

    function touchControlsLeft(setup=true){
        var tControlIconIndex = [20,23,21,22,0,42,40,43,41,0,0,0]
        //x1-=64
        //y1-=120
        if(setup==false){
            
            ctx.fillStyle = 'grey'
            //ctx.globalAlpha = 0.78//.45
            if(touchControlVisible==false)return
            ctx.globalAlpha = 0.8
            ctx.fillStyle = 'black'
            ctx.fillRect(   touchControlsLeftX-touchButtonWidth-6,
                            touchControlsLeftY-touchButtonHeight-6,
                            touchButtonWidth*3+6,(touchButtonHeight*3+12))
            ctx.globalAlpha = 1
            ctx.fillStyle = 'rgb(160,160,160)'
            ctx.fillRect(   touchControlsLeftX-touchButtonWidth-6,
                            touchControlsLeftY-touchButtonHeight-6,
                            touchButtonWidth*3+6,3)
            ctx.fillRect(   touchControlsLeftX-touchButtonWidth-6,
                            touchControlsLeftY-touchButtonHeight+(touchButtonHeight*3),
                            touchButtonWidth*3+6,3)

        }
        var cnt = 0
        for(var y=-1;y<=1;y+=1){
            for(var x=-1;x<=1;x+=1){

                if(setup==false){
                    if(touchControlVisible==false)return

                    ctx.fillRect(   touchControlsLeftX+(x*(touchButtonWidth)),
                                    touchControlsLeftY+(y*(touchButtonHeight)),
                                touchButtonWidth*.9,touchButtonHeight*.9)
                    ctx.drawImage(
                        iconImage,
                        tileAtlasIndex[tControlIconIndex[cnt]].x,
                        tileAtlasIndex[tControlIconIndex[cnt]].y,
                        tileImageCellSize , tileImageCellSize,
                        touchControlsLeftX+(x*(touchButtonWidth))+(touchButtonWidth/2-tilewidth/2),
                        touchControlsLeftY+(y*(touchButtonHeight))+(touchButtonHeight/2-tileheight/2),
                        tilewidth,tileheight
                        )
                }else{
                    touchAreaDownX.push((touchControlsLeftX+(x*(touchButtonWidth))))
                    touchAreaDownY.push((touchControlsLeftY+(y*(touchButtonHeight*1.1))))
                    touchAreaWidth.push(touchButtonWidth)
                    touchAreaHeight.push(touchButtonHeight)
                    
                
                }
                cnt+=1
            }
        }
        if(setup==false)ctx.globalAlpha = 1
    }
    function touchHandler(e){
        if(touchControlVisible==false)touchControlVisible=true
        if(e.type=="touchstart" && e.touches) {
            var x = e.changedTouches[0].clientX;
            var y = e.changedTouches[0].clientY;
            lasttouchx = x;
            lasttouchy = y;
            for(var j=0;j<e.changedTouches.length;j+=1){
            x = e.changedTouches[j].clientX;
            y = e.changedTouches[j].clientY;
            for(var i=0;i<touchAreaDownX.length;i+=1){
                if(rectsoverlap(touchAreaDownX[i],touchAreaDownY[i],touchAreaWidth[i],touchAreaHeight[i],
                    x,y,1,1)){
                        setController(i,true)
                }
            }
            }

            e.preventDefault();
        }
       if(e.type=="touchmove" && e.touches) {
            var x = e.changedTouches[0].clientX;
            var y = e.changedTouches[0].clientY;
            //touchDownX[i] = e.changedTouches[i].clientX
            //touchDownY[i] = e.changedTouches[i].clientY    

   
            for(var j=0;j<e.changedTouches.length;j+=1){
            x = e.changedTouches[j].clientX;
            y = e.changedTouches[j].clientY;
            for(var i=0;i<touchAreaDownX.length;i+=1){
                if(rectsoverlap(touchAreaDownX[i],touchAreaDownY[i],touchAreaWidth[i],touchAreaHeight[i],
                    x,y,1,1)==false){
                        setController(i,false)
                        
                }
            }
            }
                        for(var j=0;j<e.changedTouches.length;j+=1){
            x = e.changedTouches[j].clientX;
            y = e.changedTouches[j].clientY;
            for(var i=0;i<touchAreaDownX.length;i+=1){
                if(rectsoverlap(touchAreaDownX[i],touchAreaDownY[i],touchAreaWidth[i],touchAreaHeight[i],
                    x,y,1,1)==true){
                        setController(i,true)
                }
            }
            }


//                touchDownX[i] = e.changedTouches[i].clientX
//                touchDownY[i] = e.changedTouches[i].clientY    
            
        
            e.preventDefault();
        }        
        if(e.type=="touchend" && e.touches) {
            var x = e.changedTouches[0].clientX;
            var y = e.changedTouches[0].clientY;
            //touchDownX[i] = e.changedTouches[i].clientX
            //touchDownY[i] = e.changedTouches[i].clientY    
            if(Controller.MiniMap==true)Controller.MiniMap=false
            for(var i=0;i<touchAreaDownX.length;i+=1){
                if(rectsoverlap(touchAreaDownX[i],touchAreaDownY[i],touchAreaWidth[i],touchAreaHeight[i],
                    x,y,1,1)==true){
                        
                        setController(i,false)
                }
            }

//                touchDownX[i] = e.changedTouches[i].clientX
//                touchDownY[i] = e.changedTouches[i].clientY    
            

            e.preventDefault();

            // This here is to toggle the full screen mode 0/1
            var msc = 2
            if(screenwidth<1000)msc=1.3
            var x = e.changedTouches[0].clientX/msc;
            var y = e.changedTouches[0].clientY/msc;            
            //ctx2.fillText("Toggle Fullscreen",screenwidth/msc-128,10)
            if(rectsoverlap(x,y,1,1,screenwidth/msc-200,10,200,16)){
                //toggleFullScreen();
                setToggleFullScreenMode = true
            }

        }

    }
    //
    // Set controller from the touch handler (touch screen)
    //
    function setController(num,set){
        //Controller.Down=false;
        //Controller.Left=false
        //Controller.Right=false
        //Controller.Up=false
        //Controller.ShotGun=false
        //Controller.Grenade=false
        Controller.LaserWall=false
        Controller.Jump=false

        
        // typewriter style left top to right bottom

        // left side controller
        if(num==0){
            if(Controller.Right==false)Controller.Left=set
            Controller.Up=set
            //myplayer.facing="left"
            //console.log("set:"+Controller.Left+","+Controller.Up)
        }
        if(num==1){
            Controller.Up=set
        }
        if(num==2){            
            if(Controller.Left==false)Controller.Right=set
            Controller.Up=set
            //if(set==false)myplayer.facing="right"
        }
        if(num==3){
            if(Controller.Right==false)Controller.Left=set
        }
        if(num==5){
            if(Controller.Left==false)Controller.Right=set
        }
        if(num==6){
            if(Controller.Right==false)Controller.Left=set
            Controller.Down=set
            //if(set==true)myplayer.facing="left"
        }
        if(num==7){
            Controller.Down=set
        }
        if(num==8){
            if(Controller.Left==false)Controller.Right=set
            Controller.Down=set
            //if(set==false)myplayer.facing="right"
        }
        //
        // right side controller
        if(num==9){
            Controller.MiniMap = set
        }
        if(num==15){
            Controller.ShotGun=set
        }
        if(num==13){
            Controller.Jump=set
        }
        if(num==10){
            Controller.Grenade=set
        }
        if(num==17){
            Controller.LaserWall=set
        }
        
    }
    function resizeHandler(e){   
        screenwidth=window.innerWidth+48;
        screenheight=window.innerHeight+48;
        touchButtonWidth = screenwidth*.064
        touchButtonHeight = screenheight/16

        touchControlsLeftX = screenwidth*.13
        touchControlsLeftY = screenheight-(touchButtonHeight*3)-56//.66
        touchControlsRightX = screenwidth*.70
        touchControlsRightY = screenheight-(touchButtonHeight*3)-56//.66
        myplayer.maptileswidth = Math.floor(screenwidth / myplayer.tw);
        myplayer.maptilesheight = Math.floor(screenheight / myplayer.th);
        myplayer.mcx=Math.floor(myplayer.px/tilewidth)-Math.floor(myplayer.maptileswidth/2);
        myplayer.mcy=Math.floor(myplayer.py/tilewidth)-Math.floor(myplayer.maptilesheight/2);
        offscreenCanvas.width=window.innerWidth-32;
        offscreenCanvas.height=window.innerHeight-32;
        touchAreaDownX = []
        touchAreaDownY = []
        touchAreaWidth = []
        touchAreaHeight = []
        touchControlsLeft(true)
        touchControlsRight(true)
        mymap.sw = screenwidth-48
        mymap.sh = screenheight-48
        mymap.numScreenTilesHor = Math.floor(screenwidth / tilewidth)
        mymap.numScreenTilesVer = Math.floor(screenheight / tileheight)
        mymap.tw = mymap.sw/mymap.mmw;
        mymap.th = mymap.sh/mymap.mmh;
        
        mymenuselect.sw1=(screenwidth*.2)
        mymenuselect.sw2=(screenwidth*.2)
        mymenuselect.sw3=(screenwidth*.2)

        mymenuselect.x2 = ((screenwidth)/2)-(mymenuselect.sw2)
        mymenuselect.x3 = (screenwidth)-(mymenuselect.sw3*2)
        mymenuselect.y1 = (screenheight*.25)
        mymenuselect.y2 = (screenheight*.25)
        mymenuselect.y3 = (screenheight*.25)

    } 
    function toggleFullScreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
    } else if (document.exitFullscreen) {
        document.exitFullscreen();
    }
    }    
</script>
</body>
</html>
